//  CITS2002 Project 1 2024
//  Student1:   23630652   Zac Maslen
//  Student2:   24000895   Alexandra Mennie
//  Platform:   Linux  

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// defining array size to take in .ml lines
#define MY_SIZE 1000
#define MAX_NODES 1000

// initalise different token types for our lexer, values described in comments
typedef enum { 
    TknIdentifier, 
    TknNumber, 
    TknFloat, 
    TknFunction, // "function"
    TknPrint, // "print"
    TknReturn, // "return"
    TknNewline, // "\n" 
    TknTab, // "TABx" where x is the number of tabs so far through perusal
    TknAssignmentOperator, // "<-"
    TknTermOperator, // "+" or "-"
    TknFactorOperator, // "*" or "/"
    TknLBracket, // "(" 
    TknRBracket, // ")"
    TknComma, // ","
    TknEnd // "END" 
} TknType;

// define structure for "Token" as a 'type' and 'value' pair
typedef struct { 
    TknType type;
    char value[100]; } // size set as 100 as we shouldn't encounter a value more than 100 bytes long  
Token;

// node types for AST 
typedef enum {
    nodeProgram, // actual root program
    nodeStmt, 
    nodeExpression,
    nodeTerm,
    nodeFactor,
    nodeFunctionCall,
    nodeFunctionDef,
    nodeReturn,
    nodeAssignment,
    nodePrint
} NodeType;

// AST Structure
typedef struct AstNode {
    NodeType type;
    union {
        // to account for lines/statements in program we need to create an overarching program node
        struct {
            struct AstNode **programItems; // holds all statements in program
            int lineCount;
        } program;

                // func def node
        struct {
            char *identifier;
            char** params; // array of parameter names
            int paramCount;
            struct AstNode **stmt; // array of statment nodes
            int stmtCount;
            int isReturn;
            bool hasOperators;

        } funcDef;
        
        // statement node
        struct {
        NodeType type; // Add a type to differentiate between statement types
            union {
                struct {
                    struct AstNode *exp; // For assignment statements
                    char *identifier; // Variable name
                } assignment;

                struct {
                    struct AstNode *exp; // For print statements
                } print;

                struct {
                    struct AstNode *exp; // For return statements
                } returnStmt;

                struct {
                    char* identifier;
                    struct AstNode **args;
                    int argCount;
                } funcCall;
            } data;
        } stmt;
        
        // expression node
        struct {
            struct AstNode *lVar; // 
            char *oper; // + or -
            struct AstNode *rVar;
        } Expression;
        
        // term node
        struct {
            struct AstNode *lVar;
            char *oper; // x or /
            struct AstNode *rVar;
        } term;
        
        // factor node
        struct {
            float constant; // using float as we only require 6 digits of prec
            char* identifier;
            struct AstNode *funcCall;
            struct AstNode *exp; // expressions in parentheses
        } factor;

        // func call node
        struct {
            char* identifier;
            struct AstNode **args;
            int argCount;
        } funcCall;
        
        // assignment node
        struct {
            char* identifier; // var
            struct AstNode *exp;
        } assignment;
        
        // print
        struct {
            struct AstNode *exp;
        } print;
        
        // return
        struct {
            struct AstNode *exp;
        } returnStmt;
    } data;
} AstNode;

// ###################################### TOKENISATION START ######################################

// FOR TESTING PURPOSES - print the token
void print_token(Token token) {
    printf("Token Type: %d, Value: %s\n", token.type, token.value);
}


// initalise "Tokens" array
Token Tokens[1000]; // array that stores all tokens generated by the lexer
int TknIndex = 0; // integer value that keeps track of our current position in array
int TknCount = 0; // stores the number of tokens in our array
int argsCount = 0; // store number of args called

// function to add tokens to our "Tokens" array
void addToken(TknType type, const char *value) { 
    Tokens[TknIndex].type = type; // sets type
    strcpy(Tokens[TknIndex].value, value); // sets value 
    TknIndex++; // increases token index/position pointer
    TknCount++; // increment token count
}

// function to check validity of identifiers
bool isValidIdentifier(const char *str) {
    int length = strlen(str);
    if (length < 1 || length > 12) { // check length between 1 and 12
        return false;
    }
    for (int i = 0; i < length; i++) { // check all characters are lowercase and alphabetical 
        if (!islower(str[i]) || !isalpha(str[i])) {
            return false;
        }
    }
    return true;
}

int lineCount(FILE *file) {
    int count = 0;
    char c;
    while ((c = fgetc(file)) != EOF) {
        if (c == '\n') {
            count++;
        }
    }
    rewind(file);
    return count;
}

void tokenize(const char *code) {
    const char *pointer = code; // accesses character in code
    int IndentLevel = 0; // integer to track indent level

    while (*pointer) {

        // check for comments first (to remove them from consideration and avoid errors later on)
        if (*pointer == '#') {

            // skip everything until the newline character
            while (*pointer && *pointer != '\n') {
                pointer++;
            }
            continue;  // skip until newline, negating whole comment line from tokens array
            }

        // check for blank spaces such as tab and newline
        if (isspace(*pointer)) { 
            if (*pointer == '\t') { // if tab exists
                char TempBuffer[100]; // creates buffer to store characters, size should not exceed 100
                sprintf(TempBuffer, "TAB%d", IndentLevel++); // string creation of value for tab token
                addToken(TknTab, TempBuffer); // adds buffer as token
            } 
            else if (*pointer == '\n') { //if newline exists
                addToken(TknNewline, "\n"); 
                IndentLevel = 0;
            }
            pointer++; // loops if ' ' appears
            continue;
            }

        // check for numbers (real constant values)
        else if (isdigit(*pointer)) { // if integer number or float (aka. realconstant) exists
            char TempBuffer[100] = {0}; // intialises all characters in buffer to 0 
            int i = 0; // iterator 
            bool hasDecimalPoint = false; // needed for syntax error checking
            
            while (isdigit(*pointer)) { // increment and extract digits before decimal point
                 TempBuffer[i++] = *pointer++; // 
            }

            if (*pointer == '.') { // handle floats
                if (hasDecimalPoint) { // check for if multiple decimal points exist
                    fprintf(stderr, "! Syntax Error: Multiple decimal points in number.\n Recommendation: Check all numbers for incorrect format.\n");
                    exit(1);
                }

                hasDecimalPoint = true;
                TempBuffer[i++] = *pointer++; // decimal point added 

                while (isdigit(*pointer)) { // increment and extract digits after decimal point
                    TempBuffer[i++] = *pointer++;
                }
                
                addToken(TknFloat, TempBuffer); // if float exists

            } else { // if number exists
                addToken(TknNumber, TempBuffer);
            }

            // I think this may be the better way of checking for invalid characters after a number,
            // bc in ml its acceptable to find whitespaces after tokens -- but just double check LMAO

            if (!isspace(*pointer) && *pointer != '+' && *pointer != '-' && *pointer != '*' && *pointer != '/' && 
            *pointer != '(' && *pointer != ')' && *pointer != ',' && *pointer != '\0') {
                fprintf(stderr, "! Syntax Error: Invalid character '%c' after number.\nRecommendation: Ensure that numbers are followed by operators, spaces, or valid symbols.\n", *pointer);
                exit(1);
            }

        }

        else if (isalpha(*pointer) && islower(*pointer)) { // alphabetical lower case only
            char TempBuffer[100] = {0};
            int i = 0;
            while (isalnum(*pointer)|| *pointer == '_') { // more general isalnum() allows for us to pass invalid strings into identifier checker, meaning that this specific error can be accurately flagged
            TempBuffer[i++] = *pointer++; } 
            TempBuffer[i] = '\0'; // Null-terminate the buffer

            if (strcmp(TempBuffer, "function") == 0) { 
                addToken(TknFunction, TempBuffer);
            }
            else if (strcmp(TempBuffer, "print") == 0) { 
                addToken(TknPrint, TempBuffer);
            } 
            else if (strcmp(TempBuffer, "return") == 0) { 
                addToken(TknReturn, TempBuffer);
            } else if (strcmp(TempBuffer, "arg") == 0) { 
                pointer++;
                if (isdigit(*pointer)) {
                    int j = 0;
                    char argBuffer[100] = {0};
                    // Copy "arg"
                    argBuffer[j++] = 'a';
                    argBuffer[j++] = 'r';
                    argBuffer[j++] = 'g';
                    while (isdigit(*pointer)) {
                        argBuffer[j++] = *pointer++;
                    }
                    addToken(TknIdentifier, argBuffer); // argument token
                    argsCount++;
                }
                else {
                    fprintf(stderr, "! Syntax Error: Invalid character after 'arg' characters in code. Any variable starting with 'arg' is a reserved name for accessing command line arguments \n");
                    exit(1);
                }
            }
            else if (isValidIdentifier(TempBuffer)) { // if valid identifier exists 
                addToken(TknIdentifier, TempBuffer);
            } 
            else { // if invalid string exists
                fprintf(stderr, "! Syntax Error: Invalid characters in identifier or string.\n Recommendation: Ensure all characters are lower case. Identifiers should be alphabetical only and between 1 and 12 characters long. \n");
                exit(1);
            }
            continue;
            }             

        // check for mathematical operators
        else if (*pointer == '+' || *pointer == '-' || *pointer == '*' || *pointer == '/' || *pointer == '(' || *pointer == ')'|| *pointer == ',') { // if valid character
            char TempBuffer[2] = {*pointer, '\0'};
            TknType TknType;
                switch (*pointer) {
                    case '+':
                    case '-':
                        TknType = TknTermOperator;  // if '+' and '-' (term operators) exists
                        break;
                    case '*':
                    case '/':
                        TknType = TknFactorOperator;  // if '*' and '/' (factor operators) exists
                        break;
                    case '(':
                        TknType = TknLBracket;
                        break;
                    case ')':
                        TknType = TknRBracket;  // if '(' and ')' (brackets) exists
                        break;
                    case ',':
                        TknType = TknComma;  // if ',' (comma) exists
                        break;
        } 
        
        // was missing addToken after each case, so added here
        addToken(TknType, TempBuffer);
        pointer++;

        // check for assignment operator
        } else if (*pointer == '<' && *(pointer + 1) == '-') { // if "<-" operator exists
            addToken(TknAssignmentOperator, "<-");
            pointer += 2;
        }

        // check for all other characters
        else { 
            fprintf(stderr, "! Syntax Error: Illegal character '%c' exists in file.\n Recommendation: remove invalid symbols and all uppercase to fix. \n", *pointer); // just added what character its throwing an error for 
            exit(1);
        }
    }
}

// function to read contents of a .ml file
int readFile(const char *filename) {

    // opening file for reading
    FILE *file = fopen(filename, "r");
    
    // error checking: file does not exist
    if (file == NULL) {
        fprintf(stderr, "@ Error: Could not open file %s\n", filename);
        return -1;
    }

    // buffer holds each line
    char line[MY_SIZE]; 
    
    // file reading logic
    while (fgets(line, sizeof(line), file) != NULL) {
        // tokenize
        // printf("Line: %s\n", line); // debug
        tokenize(line);
    }

    // error checking: file is empty
    if (ferror(file)) {
        printf("@ Error: Could not read file %s\n", filename);
        fclose(file);
        return -1;
    }
    
    // closes file
    fclose(file);

    // At the end of input, add an end token
    addToken(TknEnd, "END"); // Add end token when reaching the end of the code

    return 0;
}

// ###################################### TOKENISATION END ######################################

// ###################################### PARSING START ######################################

// Compiler throwing hissy fit hence this
char *strdup(const char *s) {
    size_t len = strlen(s);
    char *dup = malloc(len + 1);
    if (dup) {
        strcpy(dup, s);
    }
    return dup;
}

AstNode* pFuncCall();
AstNode* pExpression();
AstNode* pProgram();

AstNode nodes[MAX_NODES]; // not using malloc, static allocation
int pCurrentTknIndex = 0;
int nodeCount = 0;

// Fetch the current token
Token pCurrentTkn() {
    return Tokens[pCurrentTknIndex];
}

// here is a function to grab the next token
Token getNextTkn() {
    return Tokens[pCurrentTknIndex++];
}

// Increment token index
void pMoveToNextTkn() {
    if (pCurrentTknIndex < TknCount - 1) {
        pCurrentTknIndex++;
    }
}

// add new node from token to tree
AstNode* createNode(NodeType type){
    if (nodeCount < MAX_NODES) {
        AstNode *node = &nodes[nodeCount++];
        node -> type = type;
        return node;
    } else {
        fprintf(stderr, "@ Error: Maximum no. of nodes reached. Memory allocation exhausted.");
        exit(EXIT_FAILURE);
    }
}

// Array to store function names
char ExistingFunctions[50][256]; // based on max 50 unique identifiers
int FunctionsCount = 0;  // Counter for the number of functions

// Function to add function names to the array
void addFunctionName(const char* identifier) {
    if (FunctionsCount < 50) { //
        strcpy(ExistingFunctions[FunctionsCount++], identifier);
    }
}

//Function to check if function identifer within the array
bool doesFunctionExist(const char* funcID) {
    for (int i = 0; i < FunctionsCount; i++) {
        if (strcmp(ExistingFunctions[i], funcID) == 0) {
            return true; // name already exists
        }
    }
return false;
}

bool hasOperatorInExpression(AstNode* node) {
    if (!node) return false;

    switch (node->type) {
        case nodeExpression:
        case nodeTerm:
            // If the expression or term has an operator, return true
            if (node->data.Expression.oper != NULL || node->data.term.oper != NULL) {
                return true;
            }

            // Recursively check the left and right variables of the expression/term
            if (hasOperatorInExpression(node->data.Expression.lVar) || 
                hasOperatorInExpression(node->data.Expression.rVar)) {
                return true;
            }
            break;

        case nodeFactor:
            // If it's a function call or nested expression, check that recursively
            if (node->data.factor.funcCall) {
                return hasOperatorInExpression(node->data.factor.funcCall);
            } else if (node->data.factor.exp) {
                return hasOperatorInExpression(node->data.factor.exp);
            }
            break;

        default:
            break;
    }

    return false;
}


AstNode* pFactor() {
    AstNode* factorNode = NULL;
    
    // check for number existence
    if (pCurrentTkn().type == TknNumber) {
        factorNode = createNode(nodeFactor);
        factorNode -> data.factor.constant = atof(pCurrentTkn().value);
        pMoveToNextTkn();
    }
    // check for float existence
    else if (pCurrentTkn().type == TknFloat) {
        factorNode = createNode(nodeFactor);
        factorNode -> data.factor.constant = atof(pCurrentTkn().value);
        pMoveToNextTkn();
    } 
    else if (pCurrentTkn().type == TknIdentifier) {
        // if function call
        if (doesFunctionExist(pCurrentTkn().value)) { 
            factorNode = createNode(nodeFactor);
            factorNode -> data.factor.funcCall = pFuncCall();
        }
        //not function call
        else    {
            factorNode = createNode(nodeFactor);
            factorNode -> data.factor.identifier = strdup(pCurrentTkn().value);
            pMoveToNextTkn();
            //if (pCurrentTkn().type != TknNewline && pCurrentTkn().type != TknEnd) {
            //    printf ("! SYNTAX ERROR: Expected new line after non-function name identifier\n.");
            //    exit(1);
            //}
        }
    } else if (pCurrentTkn().type == TknLBracket) {
        pMoveToNextTkn();
        factorNode = createNode(nodeFactor);
        // check stuff within the brackets 
        factorNode -> data.factor.exp = pExpression();
            if(pCurrentTkn().type != TknRBracket) {
                printf("! SYNTAX ERROR: Invalid factor. Expected ')' after expression.\n");
                exit(1);
            }    
        pMoveToNextTkn(); // consume ')
        return factorNode;
        
    } 
    else {
        printf(" TOKEN : '%s' (Type: %d)\n", pCurrentTkn().value, pCurrentTkn().type);
        printf("! SYNTAX ERROR: Invalid factor. Expected functioncall, real constant, identifer or '(' expression ')'.\n.");
        exit(1);
    }
    return factorNode;
}

// creating that left right operator child tree
AstNode* pTerm(){
    AstNode* fctrNode = pFactor(); // parse first factor
    // if is factor operator must parse recursively

    // debug
    if (!fctrNode) {
        printf("! SYNTAX ERROR: Expected a valid factor.\n");
        return NULL; // Handle error
    }
    while (pCurrentTkn().type == TknFactorOperator) {
        char* oper = strdup(pCurrentTkn().value); // store oper


        pMoveToNextTkn(); // move to next token
        AstNode* rVarNode = pTerm(); // parse next token

        // debug
        if (!rVarNode) {
            printf("! SYNTAX ERROR: Expected valid factor after operator '%s'.\n", oper);
            free(oper); // Clean up
            return NULL; // Handle error
        }

        AstNode* termNode = createNode(nodeTerm);
        termNode -> data.term.lVar = fctrNode; // node given lVar property i.e. the left factor 
        termNode -> data.term.rVar = rVarNode; // right variable 
        termNode -> data.term.oper = oper; // operator assigned as well
        fctrNode = termNode; 
    } 
    return fctrNode;
}

AstNode* pExpression(){
    AstNode* termNode = pTerm(); // parse first term
    if (!termNode) {
        printf("! SYNTAX ERROR: Expected a valid term.\n");
        return NULL; // Return or handle error
    }
    
    while (pCurrentTkn().type == TknTermOperator) {
        char* oper = strdup(pCurrentTkn().value);
        pMoveToNextTkn();
        AstNode* rVarNode = pExpression();

        // debug
        if (!rVarNode) {
            printf("! SYNTAX ERROR: Expected valid expression after operator '%s'.\n", oper);
            free(oper); // Clean up
            return NULL; // Handle error
        }

        AstNode* exprNode = createNode(nodeExpression);
        exprNode -> data.Expression.lVar = termNode; 
        exprNode -> data.Expression.oper = oper;
        exprNode->data.Expression.rVar = rVarNode;
        termNode = exprNode;
    
    } 
    return termNode;
}

#define MAX_ARGS 1000
AstNode* pFuncCall() {
    AstNode* funcCallNode = createNode(nodeFunctionCall);

    // Consume (EDIT: STORE) the function name
    if (pCurrentTkn().type == TknLBracket) {
    funcCallNode -> data.funcCall.identifier = strdup(Tokens[pCurrentTknIndex -1].value);
    printf("FumcCall: %s\n", funcCallNode->data.funcCall.identifier);
    }
    else {
    funcCallNode -> data.funcCall.identifier = strdup(Tokens[pCurrentTknIndex].value);
    printf("FumcCall: %s\n", funcCallNode->data.funcCall.identifier);
    }
    pMoveToNextTkn(); // function identifier eaten    
    // throwing errors so lets do some malloc bullcrap
    funcCallNode -> data.funcCall.args = malloc(sizeof(AstNode*) * MAX_ARGS);
    funcCallNode -> data.funcCall.argCount = 0;

    // Check for the left bracket
    if (pCurrentTkn().type == TknLBracket) {
        pMoveToNextTkn();  // Consume '('
    }
    else {
        printf("! SYNTAX ERROR: Expected '(' after functioncall.\n");
        exit(1);
    }
    
    while (1) {
    if (pCurrentTkn().type == TknRBracket) {
        break;  // End of arguments
    } else if (pCurrentTkn().type == TknEnd || pCurrentTkn().type == TknNewline) {
        printf("! SYNTAX ERROR: Unexpected end or newline in function call arguments.\n");
        break;  // Exit early if we hit an end or newline
    }
    // Parse 
    AstNode* paramNode = pExpression();
    if (paramNode) {
        funcCallNode->data.funcCall.args[funcCallNode->data.funcCall.argCount++] = paramNode;
    } else {
        printf("! SYNTAX ERROR: Invalid factor. Expected valid expression.\n");
        exit(1);
    }

    // Check for additional parameters
    if (pCurrentTkn().type == TknComma) {
        pMoveToNextTkn();  // Consume ','
    } else if (pCurrentTkn().type != TknRBracket) {
        printf("! SYNTAX ERROR: Expected ',' or ')' in function call arguments.\n");
        exit(1);
    }
}
    // Check for the right parenthesis ')'
    if (pCurrentTkn().type == TknRBracket) {
         pMoveToNextTkn();  // Consume ')'} 
        return funcCallNode;
        
    } else {
        printf("! SYNTAX ERROR: Expected ')' after function parameters.\n");
        exit(1);
    }
}

#define MAX_VARIABLES 50

char variableNames[MAX_VARIABLES][12];
int variableCount = 0;

// Function to add a variable name
void addVariable(const char* name) {
    if (variableCount < MAX_VARIABLES) {
        strncpy(variableNames[variableCount++], name, 12);
    }
}

// parsing over statements
AstNode* pStmt() {
    AstNode* stmtNode = createNode(nodeStmt);
    
    switch (pCurrentTkn().type) {
        case TknIdentifier:            
            if (doesFunctionExist(pCurrentTkn().value)) {
                // stmtNode -> data.stmt.data.funcCall;
                stmtNode->data.stmt.data.funcCall.identifier = strdup(pCurrentTkn().value);
                pMoveToNextTkn(); // consume identifier

//identical to function call but need repeat for reasons
                
                // throwing errors so lets do some malloc 
                stmtNode -> data.stmt.data.funcCall.args = malloc(sizeof(AstNode*) * MAX_ARGS);
                stmtNode -> data.stmt.data.funcCall.argCount = 0;

                // Check for the left bracket
                if (pCurrentTkn().type == TknLBracket) {
                    pMoveToNextTkn();  // Consume '('
                }
                else {
                    printf("! SYNTAX ERROR: Expected '(' after functioncall.\n");
                    exit(1);
                }

                while (1) {
                    if (pCurrentTkn().type == TknRBracket) {
                     break;  // End of arguments
                } else if (pCurrentTkn().type == TknEnd || pCurrentTkn().type == TknNewline) {
                    printf("! WARNING: Unexpected end or newline in function call arguments.\n");
                    break;  // Exit early if we hit an end or newline
                }

                // Parse the expression
                AstNode* paramNode = pExpression();
                if (paramNode) {
                    stmtNode->data.stmt.data.funcCall.args[stmtNode->data.stmt.data.funcCall.argCount++] = paramNode;
                } else {
                    printf("! SYNTAX ERROR: Invalid factor. Expected valid expression.\n");
                    exit(1);
                }

                // Check for additional parameters
                if (pCurrentTkn().type == TknComma) {
                    pMoveToNextTkn();  // Consume ','
                } else if (pCurrentTkn().type != TknRBracket) {
                    printf("! SYNTAX ERROR: Expected ',' or ')' in function call arguments.\n");
                    exit(1);
                }
                }
                // Check for the right parenthesis ')'
                if (pCurrentTkn().type == TknRBracket) {
                    pMoveToNextTkn();  // Consume ')'}         
                } else {
                    printf("! SYNTAX ERROR: Expected ')' after function parameters.\n");
                    exit(1);
                }
    /// identical code to function caller but need it for reasons 

                stmtNode->type = nodeFunctionCall;
                break;
            } else {
                // assignment
                addVariable(pCurrentTkn().value);
                stmtNode -> data.stmt.data.assignment.identifier = strdup(pCurrentTkn().value); // store identifier
                pMoveToNextTkn(); // move to next token
                
                //check assignment operator correctly exists here
                if (pCurrentTkn().type == TknAssignmentOperator) {
                    pMoveToNextTkn(); // consume the assignment operator
                    
                    stmtNode -> data.stmt.data.assignment.exp = pExpression();
                    stmtNode -> type = nodeAssignment;
                
                    // validate expression exists for assignment operator 
                    if (!stmtNode->data.stmt.data.assignment.exp) {
                        printf("! SYNTAX ERROR: Expected a valid expression term after assignment operator '<-'.\n");
                        exit(EXIT_FAILURE);
                    }
                } else {
                    printf("! SYNTAX ERROR: Expected assignment operator '<-' after non-function name identifier.\n") ;
                    exit(EXIT_FAILURE);
                }     
                break;
            }

        case TknPrint:
            pMoveToNextTkn(); // eat print nom nom nom 
            stmtNode -> data.stmt.data.print.exp = pExpression();
            stmtNode -> type = nodePrint;

            // validate that expression exists
            if (!stmtNode->data.stmt.data.print.exp) {
                printf("! SYNTAX ERROR: Expected a valid expression after 'print'.\n");
                exit(EXIT_FAILURE);
            }
            break;

        case TknReturn:
            pMoveToNextTkn();
            stmtNode->data.stmt.data.returnStmt.exp = pExpression();
            stmtNode->type = nodeReturn;
            
            // Validate that the expression is valid
            if (!stmtNode->data.stmt.data.returnStmt.exp) {
                printf("! SYNTAX ERROR: Expected a valid expression after 'return'.\n");
                exit(EXIT_FAILURE);
            }
            break;
        default:
            // error rip
            printf("! SYNTAX ERROR: Unexpected token. valid statement starting args include print, return and function calls.");
            exit(EXIT_FAILURE);
    }
    return stmtNode;
}

#define MAX_PARAMS 100
#define MAX_STATEMENTS 1000
// parsing over a function definition
AstNode* pFuncDef() {
    printf("Entering pFuncDef()\n");

    AstNode* funcDefNode = createNode(nodeFunctionDef);
    pMoveToNextTkn();  

    if (pCurrentTkn().type == TknIdentifier) {
        if (doesFunctionExist(pCurrentTkn().value)) {
            printf("! SYNTAX ERROR: Function name '%s' is already defined\n", pCurrentTkn().value);
            exit(EXIT_FAILURE);
        }

        addFunctionName(pCurrentTkn().value);
        funcDefNode->data.funcDef.identifier = strdup(pCurrentTkn().value);

        funcDefNode->data.funcDef.params = (char**)malloc(sizeof(char*) * MAX_PARAMS);
        funcDefNode->data.funcDef.paramCount = 0;
        pMoveToNextTkn();  // move to parameters

        while (pCurrentTkn().type == TknIdentifier) {
            if (funcDefNode->data.funcDef.paramCount >= MAX_PARAMS) {
                printf("! SYNTAX ERROR: Too many parameters in function definition\n");
                exit(EXIT_FAILURE);
            }
            funcDefNode->data.funcDef.params[funcDefNode->data.funcDef.paramCount++] = strdup(pCurrentTkn().value);
            pMoveToNextTkn();  // move to the next param
        }

        // newline after the function name and parameters?
        if (pCurrentTkn().type != TknNewline) {
            printf("! SYNTAX ERROR: Expected newline after function definition\n");
            exit(EXIT_FAILURE);
        }
        pMoveToNextTkn();  // Move past the newline

        funcDefNode->data.funcDef.stmt = (AstNode**)malloc(sizeof(AstNode*) * MAX_STATEMENTS);
        funcDefNode->data.funcDef.stmtCount = 0;
        funcDefNode->data.funcDef.isReturn = 0;  

        while (pCurrentTkn().type == TknTab) {
            pMoveToNextTkn();  // Move past the tab (indentation)

            if (funcDefNode->data.funcDef.stmtCount >= MAX_STATEMENTS) {
                printf("! SYNTAX ERROR: Too many statements in function body\n");
                exit(EXIT_FAILURE);
            }

            // Parse an individual statement and add it to the function's statement list
            AstNode* stmtNode = pStmt();  // Parse a statement specifically for the function
            funcDefNode->data.funcDef.stmt[funcDefNode->data.funcDef.stmtCount++] = stmtNode;
            funcDefNode->data.funcDef.stmtCount++;

            // Check if the parsed statement is a return statement
            if (stmtNode->type == nodeReturn) {
                funcDefNode->data.funcDef.isReturn = 1;
            }

            // Move to the next token after the statement
            if (pCurrentTkn().type == TknNewline) {
                pMoveToNextTkn();  // Move to the next line
            } else {
                break;  // Stop if there are no more indented statements
            }
        }

        // Make sure that the function body contains at least one statement
        if (funcDefNode->data.funcDef.stmtCount == 0) {
            printf("! SYNTAX ERROR: Function body must contain at least one statement\n");
            exit(EXIT_FAILURE);
        }
    } else {
        printf("! SYNTAX ERROR: Expected identifier for function name\n");
        exit(EXIT_FAILURE);
    }

    return funcDefNode;  // Return the created function definition node
}

AstNode* pProgItem() {
    // handle newlines (skip and continue)
    while (pCurrentTkn().type == TknNewline) {
        pMoveToNextTkn();
    }

    // check for if function definition exists
    if (pCurrentTkn().type == TknFunction) {
        return pFuncDef();
    } 
    else if (pCurrentTkn().type == TknIdentifier 
    || pCurrentTkn().type == TknPrint 
    || pCurrentTkn().type == TknReturn) {
        AstNode* stmtNode = pStmt();
        
        // Expect newline or end after each statement
        if (pCurrentTkn().type == TknNewline) {
            return stmtNode;
        } else if (pCurrentTkn().type == TknEnd) {
            return stmtNode;  
        } else {
            printf("! SYNTAX ERROR: Expected newline or end after statement, got '%s'.\n", pCurrentTkn().value);
            exit(EXIT_FAILURE);
        }
        return stmtNode;
    } else if (pCurrentTkn().type == TknEnd) {
        return NULL;
    } else if (pCurrentTkn().type == TknTab) {
            exit(EXIT_FAILURE);
    } else {
        // handle unexpected tokens
        printf("! SYNTAX ERROR: Unexpected token '%s'. Expected function definition or statement.\n", pCurrentTkn().value);
        exit(EXIT_FAILURE);
    }
}

#define MAX_LINES 10000
AstNode* pProgram() {
    AstNode* programNode = createNode(nodeProgram);
    
    // line count
    programNode -> data.program.lineCount = 0;
    programNode->data.program.programItems = (AstNode**)malloc(sizeof(AstNode*) * MAX_LINES); // CHECK THIS PLEASE
    if (!programNode -> data.program.programItems) {
        fprintf(stderr, "Memory alloc error.");
        exit(EXIT_FAILURE);
    }
    // parsing over program
    while (pCurrentTkn().type != TknEnd) {
        AstNode* programItem = pProgItem();
        if (programItem != NULL) {
            if (programNode -> data.program.lineCount < MAX_LINES) {
                programNode -> data.program.programItems[programNode->data.program.lineCount++] = programItem;
            } else {
                printf("! SYNTAX ERROR: Maximum line count exceeded.");
                exit(EXIT_FAILURE);
            }
        }
    }
    return programNode;
}

// ------------------------------------------- INTERPRETER-------------------------------------- //

//declare interpreter buffer size
#define BUFFER_SIZE 10000 // may change

char* codeBuffer; // Global buffer for C code
int bufferLength = 0;

// Free the buffer
void freeBuffer() {
    free(codeBuffer);
}

// Initialize buffer
void initBuffer() {
    codeBuffer = malloc(BUFFER_SIZE); // CHECK THIS PLEASE
    if (!codeBuffer) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    codeBuffer[0] = '\0'; // Start with an empty string
}

void addToCodeBuffer(const char* str) {
    int len = strlen(str);
    if (bufferLength + len >= BUFFER_SIZE) {
        // Resize buffer if necessary
        char* newBuffer = realloc(codeBuffer, bufferLength + len + 1);
        if (!newBuffer) {
            fprintf(stderr, "Memory reallocation failed\n");
            freeBuffer(); // Clean up existing buffer
            exit(1);
        }
        codeBuffer = newBuffer;
    }
    strcat(codeBuffer, str);
    bufferLength += len;
}

const char* getExpStr(AstNode* expr) {
    static char buffer[100]; 
    buffer[0] = '\0'; 

    if (!expr) return buffer;

    switch (expr->type) {
        case nodeFactor:
            snprintf(buffer, sizeof(buffer), "%s", expr->data.factor.identifier); 
            break;
        case nodeExpression:
            snprintf(buffer, sizeof(buffer), "%s %s %s",
                getExpStr(expr->data.Expression.lVar),
                expr->data.Expression.oper,
                getExpStr(expr->data.Expression.rVar));
            break;
        default:
            break;
    }
    return buffer;
}


void writeCFile() {
    FILE *cFile = fopen("mlProgram.c", "w");
    if (cFile == NULL) {
        fprintf(stderr, "! Error: Could not create C file\n");
        return;
    }
    fprintf(cFile, "%s", codeBuffer); // buffer to file
    fclose(cFile);
}

bool containsFunctionCall(AstNode* node) {
    if (!node) return false;

    if (node->type == nodeFunctionCall) {
        return true;
    }

    // Check if it's an expression or term and recursively check its components
    switch (node->type) {
        case nodeExpression:
            return containsFunctionCall(node->data.Expression.lVar) || 
                   containsFunctionCall(node->data.Expression.rVar);
        case nodeTerm:
            return containsFunctionCall(node->data.term.lVar) || 
                   containsFunctionCall(node->data.term.rVar);
        case nodeFactor:
            if (node->data.factor.funcCall) {
                return true; // This node contains a function call
            }
            return containsFunctionCall(node->data.factor.exp);
        default:
            return false; // No function call found in this node
    }
}

// defining translation to rudimentaty C program
void toC(AstNode* node) {

    // first we gotta check if the node is existing
    if (!node) {
        return;
    }
    switch (node->type) {
        case nodeProgram:
            addToCodeBuffer("#include <stdio.h>\n\n");

            // Generate variable declarations
            for (int i = 0; i < variableCount; i++) {
                addToCodeBuffer("AssiType ");
                addToCodeBuffer(variableNames[i]);
                addToCodeBuffer(";\n");
            }

            // Flag to check if funcdef exists
            bool functionDefined = false;
            // int storedI = 0;
            // First pass to collect function definitions
            for (int i = 0; i < node->data.program.lineCount; i++) {
                if (node->data.program.programItems[i]->type == nodeAssignment && !functionDefined) { // handle global variable
                    addToCodeBuffer("AssiType "); // to do
                    addToCodeBuffer(node->data.program.programItems[i]->data.stmt.data.assignment.identifier);
                    addToCodeBuffer(" = ");
                    toC(node->data.program.programItems[i]->data.stmt.data.assignment.exp);
                    addToCodeBuffer(";\n");
                }
                else if (node->data.program.programItems[i]->type == nodeFunctionDef) {
                    functionDefined = true;
                    toC(node->data.program.programItems[i]);
                }
            }

            // add main functions
            addToCodeBuffer("int main(int argc, char *argv[]) {\n");
            bool hasReturn = false; // flag to track if a return statement is made in main

for (int j = 0; j < node->data.program.lineCount; j++) {
    if (node->data.program.programItems[j]->type == nodePrint) { // Handle print statements
        toC(node->data.program.programItems[j]);
    } 
    else if (node->data.program.programItems[j]->type == nodeAssignment) { // Handle assignments
        toC(node->data.program.programItems[j]);
    } 
    else if (node->data.program.programItems[j]->type == nodeReturn) { // Handle return statements
        toC(node->data.program.programItems[j]);
        hasReturn = true;
    } else if (node->data.program.programItems[j]->type == nodeFunctionCall) { // Handle function calls in main
        toC(node->data.program.programItems[j]);
    }
}
            if (!hasReturn) {
                addToCodeBuffer("    return 0;\n");
            }
            addToCodeBuffer("}\n");
            break;
        
        case nodeFunctionDef:
            if (node->data.funcDef.isReturn == 1) {
                addToCodeBuffer("int ");
            }
            else if (node->data.funcDef.isReturn == 0) {
                addToCodeBuffer("void ");
            }
            else { 
                fprintf(stderr, "IDK what the fuck happened here\n");
                exit(1);
            }
            addToCodeBuffer(node->data.funcDef.identifier);
            addToCodeBuffer("(");

            for (int i = 0; i < node->data.funcDef.paramCount; i++) {
                if (i > 0) addToCodeBuffer(", "); 
                    addToCodeBuffer("int ");
                    addToCodeBuffer(node->data.funcDef.params[i]);
            }
            addToCodeBuffer(") {\n");

            // Add the function body
            for (int j = 0; j < node->data.funcDef.stmtCount; j++) {
                toC(node->data.funcDef.stmt[j]);
            }
            addToCodeBuffer("}\n\n");
            break;

        case nodeAssignment:
            addToCodeBuffer("AssiType ");
            addToCodeBuffer(node->data.stmt.data.assignment.identifier);
            addToCodeBuffer(" = ");
            toC(node->data.assignment.exp);
            addToCodeBuffer(";\n");
            break;

        case nodePrint:
            addToCodeBuffer("printf(");

            if (containsFunctionCall(node->data.stmt.data.print.exp)) {
                addToCodeBuffer("\"%d\\n\"");  
            } else {
                // Regular expression handling
                if (hasOperatorInExpression(node->data.stmt.data.print.exp)) {
                    addToCodeBuffer("\"%d\\n\"");  
                } else {
                    addToCodeBuffer("\"%f\\n\"");  
            }
        }
            addToCodeBuffer(", ");
            toC(node->data.stmt.data.print.exp);
            addToCodeBuffer(");\n");
            break;
        case nodeReturn:
            addToCodeBuffer("return ");
            toC(node->data.stmt.data.returnStmt.exp);
            addToCodeBuffer(";\n");
            break;
        case nodeExpression:
            toC(node->data.Expression.lVar);  
    
            if (node->data.Expression.oper != NULL) {
                addToCodeBuffer(node->data.Expression.oper); 
        } if (node->data.Expression.rVar != NULL) {
            toC(node->data.Expression.rVar);  
        } break;
        case nodeTerm:
            toC(node->data.term.lVar);  
            if (node->data.term.oper != NULL) {
                addToCodeBuffer(node->data.term.oper);  
            }
            if (node->data.term.rVar != NULL) {
                toC(node->data.term.rVar);  
            }
            break;
        case nodeFunctionCall: 
            if(node->data.funcCall.identifier == NULL) { 
                addToCodeBuffer(node->data.stmt.data.funcCall.identifier);
                addToCodeBuffer("(");
                for (int i = 0; i < node->data.stmt.data.funcCall.argCount; i++) {
                    if (i > 0) {
                        addToCodeBuffer(",");
                }
                toC(node->data.stmt.data.funcCall.args[i]);
                }
                addToCodeBuffer(");\n"); 
                break;
            }
            else {
            addToCodeBuffer(node->data.funcCall.identifier);
            addToCodeBuffer("(");
            for (int i = 0; i < node->data.funcCall.argCount; i++) {
                if (i > 0) {
                    addToCodeBuffer(",");
                }
                toC(node->data.funcCall.args[i]);
            }
            addToCodeBuffer(")"); 
            break;
            }

        case nodeFactor:
            if (node->data.factor.identifier) { 
                addToCodeBuffer(node->data.factor.identifier);
            }
            else if (node->data.factor.funcCall) { 
                toC(node->data.factor.funcCall);
            }
            else if (node->data.factor.exp) { 
                toC(node->data.factor.exp);
            }
            else { 
                char buffer[50]; 
                snprintf(buffer, sizeof(buffer), "%.6f", node->data.factor.constant);
                addToCodeBuffer(buffer);
            }
            break;

        default:
            // Handle error or unsupported node types
            fprintf(stderr, "unknown AST node type: %d\n", node->type);
    }
}

// ---------------------------------- REPLACING ASSITYPE ------------------------------//

// init struct to store var names and wheth they been operated on
typedef struct {
    char* name;
    int operated; // 1 (true) and 0 (false)
} VarInf;

// boolean func 
int isVarFound(const char* line, const char* vari) {
    const char* pos = line;
    size_t varLen = strlen(vari);
    while ((pos = strstr(pos, vari))) {
        char before = (pos == line) ? ' ' : *(pos - 1);
        char after = *(pos + varLen);
        if ((before == ' ' 
        || before == '=' 
        || before == '(' 
        || before == ',' 
        || before == ';' 
        || before == '\0') &&
            (after == ' ' 
            || after == '=' 
            || after == ')' 
            || after == ',' 
            || after == ';' 
            || after == '\0')) {
            return 1; 
            }
        pos += varLen;
        }
    return 0; 
}

// will take code and then extract variables in that code with AssiType before it
int findAssi(const char* buffer, VarInf vars[], int* varCount) {
    char* buffCpy = strdup(buffer); // duplicate buffer to maintain integrity of orig
    // init count var
    int lineCount = 0; 
    // init lines array
    char* lines[MAX_LINES];
    // if we cant copy the buffer we've run out of memory rip
    if (!buffCpy) {
        fprintf(stderr, "Memory allocation failed\n");
        return -1;
}
    // tokenise each str
    char* tLine = strtok(buffCpy, "\n");
    // from there we add each line into the array and we keep track of how many lines stored
    while (tLine) {
        lines[lineCount++] = tLine;
        tLine = strtok(NULL, "\n");
    }

    for (int lineIter = 0; lineIter < lineCount; lineIter++) {
        char* pl = strstr(lines[lineIter], "AssiType ");
        if (pl && (strchr(pl, ';') != NULL)) {
            char* varName = malloc(13); // 12 letters + whitespace
            sscanf(pl, "AssiType %12[^; ]", varName);
            vars[*varCount].name = varName;
            vars[*varCount].operated = 0; 
            (*varCount)++;
        }
    }
    free(buffCpy);
    return lineCount;
}

void checkVarPres(const char* buffer, VarInf vars[], int varCount, int lineCount) {
    char* lines[MAX_LINES];
    char* bufferCopy = strdup(buffer);
    
    if (!bufferCopy) {
        fprintf(stderr, "Memory allocation failed\n");
        return;
    }

    char* line = strtok(bufferCopy, "\n");
    int i = 0;
    
    while (line) {
        lines[i++] = line;
        line = strtok(NULL, "\n");
    }

    for (int j = 0; j < varCount; j++) {
        for (int i = 0; i < lineCount; i++) {
            if (isVarFound(lines[i], vars[j].name)) {
                if (strstr(lines[i], "=")) {
                    char* assignment = strchr(lines[i], '=');
                    if (assignment) {
                        char value[BUFFER_SIZE];
                        sscanf(assignment + 1, "%s", value); 
                        if (strchr(value, '.')) {
                            vars[j].operated = 1;
                        }
                    }
                }
                if (strstr(lines[i], "+") || strstr(lines[i], "-") || 
                    strstr(lines[i], "*") || strstr(lines[i], "/")) {
                    vars[j].operated = 1; 
                }
            }
        }
    }
    free(bufferCopy);
}

void replAssi(const char* buffer, VarInf vars[], int varCount, char* outBuff) {
    
    strcpy(outBuff, buffer); 
    
    for (int v = 0; v < varCount; v++) {
        if (vars[v].operated) {
            char oldString[BUFFER_SIZE];
            sprintf(oldString, "AssiType %s", vars[v].name);
            char newString[BUFFER_SIZE];
            sprintf(newString, "%s %s", vars[v].operated ? "float" : "int", vars[v].name);
            char* pos = outBuff;
            while ((pos = strstr(pos, oldString))) {
                strncpy(pos, newString, strlen(newString));
                memmove(pos + strlen(newString), pos + strlen(oldString), strlen(pos + strlen(oldString)) + 1);
                pos += strlen(newString); 
            }
        }
}
}
char outputBuffer[BUFFER_SIZE];
void conductAssiReplace(const char* buffer) {
    VarInf vars[MAX_LINES];
    int varCount = 0;
    int lineCount = findAssi(buffer, vars, &varCount);
    checkVarPres(buffer, vars, varCount, lineCount);
    replAssi(buffer, vars, varCount, outputBuffer); 
    for (int i = 0; i < varCount; i++) {
        free(vars[i].name);
    }
}

// ###################################### RUNNING C PROGRAM START ######################################

void compileAndRunInC() {
    system("gcc -o mlProgram mlProgram.c");
    system("./mlProgram"); // Run the executable
}

// function to remove created C file and exec file
void cleanupAfterExec() {
    remove("mlProgram.c");
    remove("mlProgram");
}

double commandLineArgs[MAX_ARGS];  // Array to hold real-valued arguments
void parseCommandLineArgs(int argc, char *argv[]) {
    for (int i = 0; i < argc - 1 && i < MAX_ARGS; i++) {
        commandLineArgs[i] = atof(argv[i + 1]);  // Convert argument to float
        printf("Argument arg%d: %f\n", i, commandLineArgs[i]);
    }
    
    // Fill remaining args with 0.0 if not provided
    for (int i = argc - 1; i < MAX_ARGS; i++) {
        commandLineArgs[i] = 0.0;
    }
}

int main(int argc, char *argv[]) {
    // error checking, if no. of args is less than 2 
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename.ml>\n", argv[0]); // changed to fprintf to print to stderr instead of default data stream
        return 1;
    }

    //initalise buffer
    initBuffer();

    // the name of the file is at initial argument provided
    char *filename = argv[1];

    // checks if file name is .ml
    size_t length = strlen(filename); // unsigned datatype, good for storing str length 
    if (length < 3 || strcmp(filename + length - 3, ".ml") != 0) {
        fprintf(stderr, "! Error: File name must end with '.ml'\n");
        return 1;
    }

    // read the file
    int status = readFile(filename); // also doing tokenisation

    if (status == -1) {
        return 1;
    }
    pCurrentTknIndex = 0;

    // Parse the code and build the AST
    AstNode* result = pProgram(); 
    if (result != NULL) {

        // Convert the AST to C code
        toC(result);
        
        conductAssiReplace(codeBuffer);

        // Write the generated C code to a file
        FILE *cFile = fopen("mlProgram.c", "w");
        if (cFile != NULL) {
            fputs(outputBuffer, cFile);
            fclose(cFile);
        } else {
            fprintf(stderr, "@ ERROR: Error writing C file.\n");
            return 1;
        }

    } else {
        fprintf(stderr, "@ ERROR: Test failed!\n");
    }
    
    compileAndRunInC();
    cleanupAfterExec();
    
    // Free the buffer memory
    freeBuffer();

    return 0;
}
