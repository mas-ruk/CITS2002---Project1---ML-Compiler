//  CITS2002 Project 1 2024
//  Student1:   23630652    Zac Doruk Maslen
//  Student2:   24000895    Alexandra Mennie
//  Platform:   Ubuntu Linux

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// defining array size to take in .ml lines
#define MY_SIZE 1000

// initalise different token types for our lexer, values described in comments
typedef enum { 
    TknIdentifier, 
    TknNumber, 
    TknFloat, 
    TknFunction, // "function"
    TknPrint, // "print"
    TknReturn, // "return"
    TknComment, // "#"
    TknNewline, // "\n" 
    TknTab, // "TABx" where x is the number of tabs so far through perusal
    TknAssignmentOperator, // "<-"
    TknTermOperator, // "+" or "-"
    TknFactorOperator, // "*" or "/"
    TknBracket, // "(" or ")"
    TknEnd // "END" 
} TknType;

// define structure for "Token" as a 'type' and 'value' pair
typedef struct { 
    TknType type;
    char value[100]; } // size set as 100 as we shouldn't encounter a value more than 100 bytes long  
Token;

// initalise "Tokens" array
Token Tokens[1000]; // array that stores all tokens generated by the lexer
int TknIndex = 0; // integer value that keeps track of our current position in array

// function to add tokens to our "Tokens" array
void addToken(TknType type, const char *value) { 
    tokens[TknIndex].type = type; // sets type
    strcpy(tokens[TknIndex].value, value); // sets value 
    TknIndex++; // increases token index/position pointer 
}

// FOR TESTING PURPOSES - print the token
void print_token(Token token) {
    printf("Token Type: %d, Value: %s\n", token.type, token.value);
}

// function to check validity of identifiers
bool isValidIdentifier(const char *str) {
    int length = strlen(str);
    if (length < 1 || length > 12) { // check length between 1 and 12
        return false;
    }
    for (int i = 0; i < length; i++) { // check all characters are lowercase and alphabetical 
        if (!islower(str[i]) || !isalpha(str[i])) {
            return false;
        }
    }
    return true;
}

int main(int argc, char *argv[]) {
    // error checking, if no. of args is less than 2 
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename.ml>\n", argv[0]); // changed to fprintf to print to stderr instead of default data stream
        return 1;
    }

    // the name of the file is at initial argument provided
    char *filename = argv[1];

    // checks if file name is .ml
    size_t length = strlen(filename); // unsigned datatype, good for storing str length 
    if (length < 3 || strcmp(filename + length - 3, ".ml") != 0) {
        fprintf(stderr, "Error: File name must end with '.ml'\n");
        return 1;
    }

    // read the file
    int status = readFile(filename);

    if (status == -1) {
        return 1;
    }
    return 0;
}

int lineCount(FILE *file) {
    int count = 0;
    char c;
    while ((c = fgetc(file)) != EOF) {
        if (c == '\n') {
            count++;
        }
    }
    rewind(file);
    return count;
}

// function to read contents of a .ml file
int readFile(char *filename) {

    // opening file for reading
    FILE *file = fopen(filename, "r");
    
    // error checking: file does not exist
    if (file == NULL) {
        fprintf(stderr, "Error: Could not open file %s\n", filename);
        return -1;
    }

    // buffer holds each line
    char line[MY_SIZE]; 
    
    // file reading logic
    while (fgets(line, sizeof(line), file) != NULL) {
        // remove new line char 
        size_t len = strlen(line);
        if (len > 0 && line[len - 1] == '\n') {
            line[len - 1] = '\0';
        }

        // tokenize
        tokenize(line);
    }

    // error checking: file is empty
    if (ferror(file)) {
        printf("Error: Could not read file %s\n", filename);
        fclose(file);
        return -1;
    }

    // real data type only supported - float, double and long double are real data types
    
    // closes file
    fclose(file);
    return 0;
}

// lexer function to convert code to token list
void tokenize(const char *code) {
    const char *pointer = code; // accesses character in code
    int IndentLevel = 0; // integer to track indent level

    while (*pointer) {

        // check for comments first (to remove them from consideration and avoid errors later on)
        if (*pointer == '#') {
            addToken(TknComment, "#");  // 

//DEBUG NEEDED: if we read line by line with newline character removed then this part will not work as expected
// FIXES? - keep newline character in?

            // skip everything until the newline character
            while (*pointer && *pointer != '\n') {
                pointer++;
            }
            continue;  // skip until newline, negating whole comment line from tokens array
            }

        // check for blank spaces such as tab and newline
        if (isspace(*pointer)) { 
            if (*pointer == '\t') { // if tab exists
                char TempBuffer[100]; // creates buffer to store characters, size should not exceed 100
                sprintf(TempBuffer, "TAB%d", IndentLevel++); // string creation of value for tab token
                addToken(TknTab, TempBuffer); // adds buffer as token
            } 
            else if (*pointer == '\n') { //if newline exists
                addToken(TknNewline, "\n"); 
                IndentLevel = 0;
            }
            pointer++; // loops if ' ' appears
            continue;
            }

        // check for numbers (real constant values)
        else if (isdigit(*pointer)) { // if integer number or float (aka. realconstant) exists
            char TempBuffer[100] = {0}; // intialises all characters in buffer to 0 
            int i = 0; // iterator 
            bool hasDecimalPoint = false; // needed for syntax error checking
            
            while (isdigit(*pointer)) { // increment and extract digits before decimal point
                 TempBuffer[i++] = *pointer++; // 
             }
            if (*pointer == '.') { // handle floats
                if (HasDecimalPoint) { // check for if multiple decimal points exist
                    fprintf(stderr, "! Syntax Error: Multiple decimal points in number.\n Recommendation: Check all numbers for incorrect format.\n");
                    exit(1);
                }
                hasDecimalPoint = true;
                TempBuffer[i++] = *pointer++; 
                    while (isdigit(*pointer)) { // increment and extract digits after decimal point
                        TempBuffer[i++] = *pointer++;
                    }
                addToken(TknFloat, TempBuffer); // if float exists
            } 
            else { // if number exists
                addToken(TknNumber, TempBuffer);
            }

            // check for invalid characters after the number
            if (!isdigit(*pointer)) {
                fprintf(stderr, "! Syntax Error: Invalid character '%c' after number.\n Recommendation: Check all numbers for invalid characters. Ensure all operators, identifiers, constants and words are properly seperated by spaces. \n");
                exit(1);
            }
        }

        // check for strings (identifiers or reserved words)
        else if (isalpha(*pointer) && islower(*pointer)) { // alphabetical lower case only
            char TempBuffer[100] = {0};
            int i = 0;
            while (isalnum(*pointer)|| *pointer == '_') { // more general isalnum() allows for us to pass invalid strings into identifier checker, meaning that this specific error can be accurately flagged
            TempBuffer[i++] = *pointer++; } 
            TempBuffer[i] = '\0'; // Null-terminate the buffer

            if (strcmp(TempBuffer, "function") == 0) { // if function keyword exists
                addToken(TknFunction, TempBuffer);
            }
            else if (strcmp(TempBuffer, "print") == 0) { // if print keyword exists
                addToken(TknPrint, TempBuffer);
            } 
            else if (strcmp(TempBuffer, "return") == 0) { // if return keyword exists
                addToken(TknReturn, TempBuffer);
            }
            else if (isValidIdentifier(TempBuffer)) { // if valid identifier exists 
                addToken(TknIdentifier, TempBuffer);
            } 
            else { // if invalid string exists
                fprintf(stderr, "! Syntax Error: Invalid characters in identifier or string.\n Recommendation: Ensure all characters are lower case. Identifiers should be alphabetical only and between 1 and 12 characters long. \n");
                exit(1);
            }
            continue;
            }             

        // check for mathematical operators
        else if (*pointer == '+' || *pointer == '-' || *pointer == '*' || *pointer == '/' || *pointer == '(' || *pointer == ')') { // if valid character
            char TempBuffer[2] = {*pointer, '\0'};
            TknType TknType;
                switch (*pointer) {
                  case '+':
                  case '-':
                    TknType = TknTermOperator;  // if '+' and '-' (term operators) exists
                    break;
                  case '*':
                  case '/':
                    TknType = TknFactorOperator;  // if '*' and '/' (factor operators) exists
                    break;
                  case '(':
                  case ')':
                    TknType = TknBracket;  // if '(' and ')' (brackets) exists
                    break;
        } 

        // check for assignment operator
        else if (*pointer == '<' && *(pointer + 1) == '-') { // if "<-" operator exists
            addToken(TknAssignmentOperator, "<-");
            pointer += 2;
        }

        // check for all other characters
        else { 
            fprintf(stderr, "! Syntax Error: Illegal character exists in file.\n Recommendation: remove invalid symbols and all uppercase to fix. \n");
            exit(1);
        }
    }
    addToken(TknEnd, "END"); // End of input
}

// defining translation to C function
void toC(FILE *cFile) {

}

void compileForC() {

}

void runInC() {

}

// function to remove created C file and exec file
void cleanupAfterExec() {

}
