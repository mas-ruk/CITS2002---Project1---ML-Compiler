//  CITS2002 Project 1 2024
//  Student1:   23630652    Zac Doruk Maslen
//  Student2:   20000000    Alexandra Mennie
//  Platform:   Ubuntu Linux

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// defining array size to take in .ml lines
#define MY_SIZE 1000

// Initalise creation of tokens which categorise all occurrences of characters and string in code that we can then evaluate ie. operators, reserved words, numbers, variables etc. 
// comments describe the value given to the types
typedef enum { 
    TknIdentifier, 
    TknNumber, 
    TknFloat, 
    TknFunction, 
    TknPrint,
    TknReturn,
    TknComment, // "#"
    TknNewline, // "/n" 
    TknTab, // TABx where x is the number of tabs so far through perusal
    TknAssignmentOperator, // "<-"
    TknAddOperator,
    TknSubtractOperator,
    TknMultiplyOperator,
    TknDivideOperator,
    TknLBracket,
    TknRBracket,
    TknEnd // "ENDPROGRAM" literal end of program
} TokenType;

typedef struct { 
    TokenType type; // assigns the enum that represents the different token types 
    char value[256]; } // assign size to tokens... may need to be reduced for efficiency? or increased?
Token;

Token tokens[1000]; // array that stores all tokens generated by the lexer... size may need to be greater? make adaptable?
int tokenIndex = 0; // keep track of current position in token index

//function to add token to our Tokens array
void addToken(TokenType type, const char *value) { 
    tokens[tokenIndex].type = type; // sets type of token being added
    strcpy(tokens[tokenIndex].value, value); // copies token value into token value field 
    tokenIndex++; //increases index so next token position is evalauted 
}

// FOR TESTING PURPOSES - print the token
void print_token(Token token) {
    printf("Token Type: %d, Value: %s\n", token.type, token.value);
}

// Function to check validity of identifiers
bool isValidIdentifier(const char *str) {
    int length = strlen(str);

    if (length < 1 || length > 12) { // check length between 1 and 12
        return false;
    }

    for (int i = 0; i < length; i++) { // check all lowercase and alphabetical 
        if (!islower(str[i]) || !isalpha(str[i])) {
            return false;
        }
    }
    return true;
}

int main(int argc, char *argv[]) {
    // error checking, if no. of args is less than 2 
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename.ml>\n", argv[0]); // changed to fprintf to print to stderr instead of default data stream
        return 1;
    }

    // the name of the file is at initial argument provided
    char *filename = argv[1];

    // checks if file name is .ml
    size_t length = strlen(filename); // unsigned datatype, good for storing str length 
    if (length < 3 || strcmp(filename + length - 3, ".ml") != 0) {
        fprintf(stderr, "Error: File name must end with '.ml'\n");
        return 1;
    }

    // read the file
    int status = readFile(filename);

    if (status == -1) {
        return 1;
    }
    return 0;
}

int lineCount(FILE *file) {
    int count = 0;
    char c;
    while ((c = fgetc(file)) != EOF) {
        if (c == '\n') {
            count++;
        }
    }
    rewind(file);
    return count;
}

// function to read contents of a .ml file
int readFile(char *filename) {
    FILE *file = fopen(filename, "r");
    // error checking: file does not exist
    if (file == NULL) {
        printf("Error: Could not open file %s\n", filename);
        return -1;
    }

    // array string needs to be large enough to hold file
    char contents[MY_SIZE];

    // TEMPORARY -- prints the contents of the file
    while (fgets(contents, MY_SIZE, file) != NULL) {
        printf("%s", contents);
    } 
    
    if (ferror(file)) {
        printf("Error: Could not read file %s\n", filename);
        fclose(file);
        return -1;
    }

    // real data type only supported - float, double and long double are real data types
    
    // closes file
    fclose(file);
    return 0;
}

//Tokenize function to convert code to token list
void tokenize(const char *code) {
    const char *pointer = code;
    int IndentLevel = 0;

    while (*pointer) {

        // Check for comments first (to remove them from consideration and avoid errors later on)
        if (*pointer == '#') {
            addToken(TknComment, "#");  // Add token comment.

//CHECK THAT THIS SKIP FUNCTION STILL HAS NEWLINE TOKEN AFTER COMMENT TOKEN???
//May be able to remove comment token entirely??

            // Skip everything until the newline character
            while (*pointer && *pointer != '\n') {
                pointer++;
            }
            continue;  // skip until newline, negating comment line from tokens
            }

        // Check for blank spaces such as tab and newline
        if (isspace(*pointer)) { 
            if (*pointer == '\t') { // if tab exists
                char TempBuffer[100]; // allocates size for buffer 
                sprintf(TempBuffer, "TAB%d", IndentLevel++); // formats and stores tab data in buffer 
                addToken(TknTab, TempBuffer); // adds buffer to token
            } else if (*pointer == '\n') { //if newline exists
                addToken(TknNewline, "\n");
                IndentLevel = 0;
            }
            pointer++;
            continue;
            }

        // Check for numbers (real constant values)
         else if (isdigit(*p)) { // Integer Number or Float (aka. realconstant)
            char TempBuffer[100] = {0};
            int i = 0; 
            while (isdigit(*pointer)) TempBuffer[i++] = *p++; //increment through all digits to extract digit until space
            if (*p == '.') { // Handle floats
                TempBuffer[i++] = *pointer++;
                while (isdigit(*pointer)) TempBuffer[i++] = *pointer++;
                addToken(TknFloat, TempBuffer);
            } else {
                addToken(TknNumber, TempBuffer);
            }
            }

        // Check for strings ( identifiers or reserved words)
          else if (isalpha(*pointer) && islower(*pointer)) { // alphabetical lower case only
            char TempBuffer[100] = {0};
            int i = 0;
            while (isalnum(*pointer)|| *pointer == '_') { // More general isalnum() allows for specific flagging and termination when invalid syntax identifier found
            TempBuffer[i++] = *pointer++; } 
            TempBuffer[i] = '\0'; // Null-terminate the buffer

            if (strcmp(TempBuffer, "function") == 0) { // function keyword
                addToken(TknFunction, TempBuffer);
            } else if (strcmp(TempBuffer, "print") == 0) { // print keyword
                addToken(TknPrint, TempBuffer);
            } else if (strcmp(TempBuffer, "return") == 0) { //return keyword
                addToken(TknReturn, TempBuffer);
            } else if (isValidIdentifier(TempBuffer)) {// valid identifier
                addToken(TknIdentifier, TempBuffer);
            } else {
                fprintf(stderr, "! SYNTAX ERROR: Invalid characters in identifier or string. RECOMMENDATION: Ensure all characters are lower case. Identifiers should be alphabetical only and between 1 and 12 characters long");
                exit(1);
            }
            continue;
            }             

      // Check for operators
          else if (*pointer == '+' || *pointer == '-' || *pointer == '*' || *pointer == '/' || *pointer == '(' || *pointer == ')') { // if valid character
            char TempBuffer[2] = {*pointer, '\0'};
            addToken(*pointer == '+' ? TknAddOperator :
                    *pointer == '-' ? TknSubtractOperator :
                    *pointer == '*' ? TknMultiplyOperator :
                    *pointer == '/' ? TknDivideOperator :
                    *pointer == '(' ? TknLBracket : TknRBracket, TempBuffer);
            pointer++;
        } else if (*pointer == '<' && *(pointer + 1) == '-') { // Handle "<-" operator
            addToken(TknAssignmentOperator, "<-");
            pointer += 2;
        } else { // other character
            fprintf(stderr, "! SYNTAX ERROR: Illegal character exists in file. RECOMMENDATION: remove invalid symbols and all uppercase to fix");
            exit(1);
        }
    }
    addToken(TknEnd, "ENDPROGRAM"); // End of input
}