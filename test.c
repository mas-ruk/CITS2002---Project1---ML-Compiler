#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// defining array size to take in .ml lines
#define MY_SIZE 1000
#define MAX_NODES 1000

// initalise different token types for our lexer, values described in comments
typedef enum { 
    TknIdentifier, 
    TknNumber, 
    TknFloat, 
    TknFunction, // "function"
    TknPrint, // "print"
    TknReturn, // "return"
    TknNewline, // "\n" 
    TknTab, // "TABx" where x is the number of tabs so far through perusal
    TknAssignmentOperator, // "<-"
    TknTermOperator, // "+" or "-"
    TknFactorOperator, // "*" or "/"
    TknLBracket, // "(" 
    TknRBracket, // ")"
    TknComma, // ","
    TknEnd // "END" 
} TknType;

// define structure for "Token" as a 'type' and 'value' pair
typedef struct { 
    TknType type;
    char value[100]; } // size set as 100 as we shouldn't encounter a value more than 100 bytes long  
Token;

// node types for AST 
typedef enum {
    nodeProgram, // actual root program
    nodeStmt, 
    nodeExpression,
    nodeTerm,
    nodeFactor,
    nodeFunctionCall,
    nodeFunctionDef,
    nodeReturn,
    nodeAssignment,
    nodePrint
} NodeType;

// AST Structure
typedef struct AstNode {
    NodeType type;
    union {
        // to account for lines/statements in program we need to create an overarching program node
        struct {
            struct AstNode **programItems; // holds all statements in program
            int lineCount;
        } program;

                // func def node
        struct {
            char *identifier;
            char** params; // array of parameter names
            int paramCount;
            struct AstNode **stmt; // array of statment nodes
            int stmtCount;
            int isReturn;

        } funcDef;
        
        // statement node
        struct {
        NodeType type; // Add a type to differentiate between statement types
            union {
                struct {
                    struct AstNode *exp; // For assignment statements
                    char *identifier; // Variable name
                } assignment;

                struct {
                    struct AstNode *exp; // For print statements
                } print;

                struct {
                    struct AstNode *exp; // For return statements
                } returnStmt;

                struct {
                    struct AstNode *funcCall; // For function calls
                } funcCall;
            } data;
        } stmt;
        
        // expression node
        struct {
            struct AstNode *lVar; // 
            char *oper; // + or -
            struct AstNode *rVar;
        } Expression;
        
        // term node
        struct {
            struct AstNode *lVar;
            char *oper; // x or /
            struct AstNode *rVar;
        } term;
        
        // factor node
        struct {
            float constant; // using float as we only require 6 digits of precision
            char* identifier;
            struct AstNode *funcCall;
            struct AstNode *exp; // expressions in parentheses
        } factor;

        // func call node
        struct {
            char* identifier;
            struct AstNode **args;
            int argCount;
        } funcCall;
        
        // assignment node
        struct {
            char* identifier; // var
            struct AstNode *exp;
        } assignment;
        
        // print
        struct {
            struct AstNode *exp;
        } print;
        
        // return
        struct {
            struct AstNode *exp;
        } returnStmt;
    } data;
} AstNode;

// we didnt have a way of representing the statements each in the program so here's a node for it
struct {
    struct AstNode **statements; // array for statements
    int statementCount;
} statementSeq;

// ###################################### TOKENISATION START ######################################

// FOR TESTING PURPOSES - print the token
void print_token(Token token) {
    printf("Token Type: %d, Value: %s\n", token.type, token.value);
}


// initalise "Tokens" array
Token Tokens[1000]; // array that stores all tokens generated by the lexer
int TknIndex = 0; // integer value that keeps track of our current position in array
int TknCount = 0; // stores the number of tokens in our array

// function to add tokens to our "Tokens" array
void addToken(TknType type, const char *value) { 
    Tokens[TknIndex].type = type; // sets type
    strcpy(Tokens[TknIndex].value, value); // sets value 
    TknIndex++; // increases token index/position pointer
    TknCount++; // increment token count
    print_token(Tokens[TknIndex - 1]);
    printf("Creating Token - Type: %d, Value: '%s'\n", type, value); // debugging
}

// function to check validity of identifiers
bool isValidIdentifier(const char *str) {
    int length = strlen(str);
    if (length < 1 || length > 12) { // check length between 1 and 12
        return false;
    }
    for (int i = 0; i < length; i++) { // check all characters are lowercase and alphabetical 
        if (!islower(str[i]) || !isalpha(str[i])) {
            return false;
        }
    }
    return true;
}

int lineCount(FILE *file) {
    int count = 0;
    char c;
    while ((c = fgetc(file)) != EOF) {
        if (c == '\n') {
            count++;
        }
    }
    rewind(file);
    return count;
}

void tokenize(const char *code) {
    const char *pointer = code; // accesses character in code
    int IndentLevel = 0; // integer to track indent level

    while (*pointer) {

        // check for comments first (to remove them from consideration and avoid errors later on)
        if (*pointer == '#') {

            // skip everything until the newline character
            while (*pointer && *pointer != '\n') {
                pointer++;
            }
            continue;  // skip until newline, negating whole comment line from tokens array
            }

        // check for blank spaces such as tab and newline
        if (isspace(*pointer)) { 
            if (*pointer == '\t') { // if tab exists
                char TempBuffer[100]; // creates buffer to store characters, size should not exceed 100
                sprintf(TempBuffer, "TAB%d", IndentLevel++); // string creation of value for tab token
                addToken(TknTab, TempBuffer); // adds buffer as token
            } 
            else if (*pointer == '\n') { //if newline exists
                addToken(TknNewline, "\n"); 
                IndentLevel = 0;
            }
            pointer++; // loops if ' ' appears
            continue;
            }

        // check for numbers (real constant values)
        else if (isdigit(*pointer)) { // if integer number or float (aka. realconstant) exists
            char TempBuffer[100] = {0}; // intialises all characters in buffer to 0 
            int i = 0; // iterator 
            bool hasDecimalPoint = false; // needed for syntax error checking
            
            while (isdigit(*pointer)) { // increment and extract digits before decimal point
                 TempBuffer[i++] = *pointer++; // 
            }

            if (*pointer == '.') { // handle floats
                if (hasDecimalPoint) { // check for if multiple decimal points exist
                    fprintf(stderr, "! Syntax Error: Multiple decimal points in number.\n Recommendation: Check all numbers for incorrect format.\n");
                    exit(1);
                }

                hasDecimalPoint = true;
                TempBuffer[i++] = *pointer++; // decimal point added 

                while (isdigit(*pointer)) { // increment and extract digits after decimal point
                    TempBuffer[i++] = *pointer++;
                }
                
                addToken(TknFloat, TempBuffer); // if float exists

            } else { // if number exists
                addToken(TknNumber, TempBuffer);
            }

            /* check for invalid characters after the number
            if (!isdigit(*pointer)) {
                fprintf(stderr, "! Syntax Error: Invalid character '%c' after number.\n Recommendation: Check all numbers for invalid characters. Ensure all operators, identifiers, constants and words are properly seperated by spaces. \n", *pointer);
                exit(1);
            }
            */

            // I think this may be the better way of checking for invalid characters after a number,
            // bc in ml its acceptable to find whitespaces after tokens -- but just double check LMAO

            if (!isspace(*pointer) && *pointer != '+' && *pointer != '-' && *pointer != '*' && *pointer != '/' && 
            *pointer != '(' && *pointer != ')' && *pointer != ',' && *pointer != '\0') {
                fprintf(stderr, "! Syntax Error: Invalid character '%c' after number.\nRecommendation: Ensure that numbers are followed by operators, spaces, or valid symbols.\n", *pointer);
                exit(1);
            }

        }

        // check for strings (identifiers or reserved words)
        else if (isalpha(*pointer) && islower(*pointer)) { // alphabetical lower case only
            char TempBuffer[100] = {0};
            int i = 0;
            while (isalnum(*pointer)|| *pointer == '_') { // more general isalnum() allows for us to pass invalid strings into identifier checker, meaning that this specific error can be accurately flagged
            TempBuffer[i++] = *pointer++; } 
            TempBuffer[i] = '\0'; // Null-terminate the buffer

            if (strcmp(TempBuffer, "function") == 0) { // if function keyword exists
                addToken(TknFunction, TempBuffer);
            }
            else if (strcmp(TempBuffer, "print") == 0) { // if print keyword exists
                addToken(TknPrint, TempBuffer);
            } 
            else if (strcmp(TempBuffer, "return") == 0) { // if return keyword exists
                addToken(TknReturn, TempBuffer);
            }
            else if (isValidIdentifier(TempBuffer)) { // if valid identifier exists 
                addToken(TknIdentifier, TempBuffer);
            } 
            else { // if invalid string exists
                fprintf(stderr, "! Syntax Error: Invalid characters in identifier or string.\n Recommendation: Ensure all characters are lower case. Identifiers should be alphabetical only and between 1 and 12 characters long. \n");
                exit(1);
            }
            continue;
            }             

        // check for mathematical operators
        else if (*pointer == '+' || *pointer == '-' || *pointer == '*' || *pointer == '/' || *pointer == '(' || *pointer == ')'|| *pointer == ',') { // if valid character
            char TempBuffer[2] = {*pointer, '\0'};
            TknType TknType;
                switch (*pointer) {
                    case '+':
                    case '-':
                        TknType = TknTermOperator;  // if '+' and '-' (term operators) exists
                        break;
                    case '*':
                    case '/':
                        TknType = TknFactorOperator;  // if '*' and '/' (factor operators) exists
                        break;
                    case '(':
                        TknType = TknLBracket;
                        break;
                    case ')':
                        TknType = TknRBracket;  // if '(' and ')' (brackets) exists
                        break;
                    case ',':
                        TknType = TknComma;  // if ',' (comma) exists
                        break;
        } 
        
        // was missing addToken after each case, so added here
        addToken(TknType, TempBuffer);
        pointer++;

        // check for assignment operator
        } else if (*pointer == '<' && *(pointer + 1) == '-') { // if "<-" operator exists
            addToken(TknAssignmentOperator, "<-");
            pointer += 2;
        }

        // check for all other characters
        else { 
            fprintf(stderr, "! Syntax Error: Illegal character '%c' exists in file.\n Recommendation: remove invalid symbols and all uppercase to fix. \n", *pointer); // just added what character its throwing an error for 
            exit(1);
        }
    }
  // At the end of input, add an end token
    addToken(TknEnd, ""); // Add end token when reaching the end of the code
}

// function to read contents of a .ml file
int readFile(const char *filename) {

    // opening file for reading
    FILE *file = fopen(filename, "r");
    
    // error checking: file does not exist
    if (file == NULL) {
        fprintf(stderr, "@ Error: Could not open file %s\n", filename);
        return -1;
    }

    // buffer holds each line
    char line[MY_SIZE]; 
    
    // file reading logic
    while (fgets(line, sizeof(line), file) != NULL) {
        // tokenize
        // printf("Line: %s\n", line); // debug
        tokenize(line);
    }

    // error checking: file is empty
    if (ferror(file)) {
        printf("@ Error: Could not read file %s\n", filename);
        fclose(file);
        return -1;
    }
    
    // closes file
    fclose(file);
    
    addToken(TknEnd, "END");

    return 0;
}

// ###################################### TOKENISATION END ######################################

// ###################################### PARSING START ######################################

// Compiler throwing hissy fit hence this
char *strdup(const char *s) {
    size_t len = strlen(s);
    char *dup = malloc(len + 1);
    if (dup) {
        strcpy(dup, s);
    }
    return dup;
}

// Prototype for the parser functions
AstNode* pFuncCall();
AstNode* pExpression();
AstNode* pProgram();

AstNode nodes[MAX_NODES]; // not using malloc, static allocation
int pCurrentTknIndex = 0;
int nodeCount = 0;

// Fetch the current token
Token pCurrentTkn() {
    return Tokens[pCurrentTknIndex];
}

// here is a function to grab the next token
Token getNextTkn() {
    return Tokens[pCurrentTknIndex++];
}

// Increment token index
void pMoveToNextTkn() {
    pCurrentTknIndex++;
}

// add new node from token to tree
AstNode* createNode(NodeType type){
    if (nodeCount < MAX_NODES) {
        AstNode *node = &nodes[nodeCount++];
        node -> type = type;
        return node;
    } else {
        fprintf(stderr, "@ Error: Maximum no. of nodes reached. Memory allocation exhausted.");
        exit(EXIT_FAILURE);
    }
}

// Array to store function names
char ExistingFunctions[50][256]; // based on max 50 unique identifiers
int FunctionsCount = 0;  // Counter for the number of functions

// Function to add function names to the array
void addFunctionName(const char* identifier) {
    if (FunctionsCount < 50) { //
        strcpy(ExistingFunctions[FunctionsCount++], identifier);
    }
}

//Function to check if function identifer within the array
bool doesFunctionExist(const char* funcID) {
    for (int i = 0; i < FunctionsCount; i++) {
        if (strcmp(ExistingFunctions[i], funcID) == 0) {
            return true; // name already exists
        }
    }
return false;
}

AstNode* pFactor() {
    printf("Entering pFactor()\n");
    AstNode* factorNode = NULL;
    
    // check for number existence
    if (pCurrentTkn().type == TknNumber) {
        printf("Found number: %f\n", atof(pCurrentTkn().value));  // Use %f for double
        factorNode = createNode(nodeFactor);
        factorNode -> data.factor.constant = atof(pCurrentTkn().value);
        pMoveToNextTkn();
    }
    // check for float existence
    else if (pCurrentTkn().type == TknFloat) {
        printf("Found number: %f\n", atof(pCurrentTkn().value));  // Use %f for double
        factorNode = createNode(nodeFactor);
        printf("Created float node");
        factorNode -> data.factor.constant = atof(pCurrentTkn().value);
        pMoveToNextTkn();
    } 
    else if (pCurrentTkn().type == TknIdentifier) {
        printf("Found identifier: %s\n", pCurrentTkn().value);
        // if function call
        if (doesFunctionExist(pCurrentTkn().value)) { 
            factorNode = createNode(nodeFactor);
            factorNode -> data.factor.funcCall = pFuncCall();
        }
        //not function call
        else    {
            factorNode = createNode(nodeFactor);
            factorNode -> data.factor.identifier = strdup(pCurrentTkn().value);
            printf("Stored identifier: %s\n", factorNode->data.factor.identifier);
            pMoveToNextTkn();
            //if (pCurrentTkn().type != TknNewline && pCurrentTkn().type != TknEnd) {
            //    printf ("! SYNTAX ERROR: Expected new line after non-function name identifier\n.");
            //    exit(1);
            //}
        }
    } else if (pCurrentTkn().type == TknLBracket) {
        printf("Found left bracket\n");
        pMoveToNextTkn();
        factorNode = createNode(nodeFactor);
        // check stuff within the brackets 
        factorNode -> data.factor.exp = pExpression();
            if(pCurrentTkn().type != TknRBracket) {
                printf("! SYNTAX ERROR: Invalid factor. Expected ')' after expression.\n");
                exit(1);
            }    
        printf("Found right bracket\n");
        pMoveToNextTkn(); // consume ')'
    } else {
        printf("! SYNTAX ERROR: Invalid factor. Expected functioncall, real constant, identifer or '(' expression ')'.\n.");
        exit(1);
    }
    printf("Exiting pFactor()\n");
    return factorNode;
}

// creating that left right operator child tree
AstNode* pTerm(){
    printf("Entering pTerm()\n");    
    AstNode* fctrNode = pFactor(); // parse first factor
    // if is factor operator must parse recursively

    // debug
    if (!fctrNode) {
        printf("! SYNTAX ERROR: Expected a valid factor.\n");
        return NULL; // Handle error
    }

    printf("Parsed factor: %f\n", fctrNode->data.factor.constant); 

    while (pCurrentTkn().type == TknFactorOperator) {
        char* oper = strdup(pCurrentTkn().value); // store oper
        printf("Found multiplication/division operator: '%s'\n", oper);


        pMoveToNextTkn(); // move to next token
        AstNode* rVarNode = pTerm(); // parse next token

        // debug
        if (!rVarNode) {
            printf("! SYNTAX ERROR: Expected valid factor after operator '%s'.\n", oper);
            free(oper); // Clean up
            return NULL; // Handle error
        }

        AstNode* termNode = createNode(nodeTerm);
        termNode -> data.term.lVar = fctrNode; // node given lVar property i.e. the left factor 
        termNode -> data.term.rVar = rVarNode; // right variable 
        termNode -> data.term.oper = oper; // operator assigned as well
        fctrNode = termNode; 
    } 
    printf("Exiting pTerm()\n");
    return fctrNode;
}

AstNode* pExpression(){
    printf("Entering pExpression() with current node %s\n", pCurrentTkn().value);
    AstNode* termNode = pTerm(); // parse first term
    if (!termNode) {
        printf("! SYNTAX ERROR: Expected a valid term.\n");
        return NULL; // Return or handle error
    }
    
    while (pCurrentTkn().type == TknTermOperator) {
        char* oper = strdup(pCurrentTkn().value);
        printf("Found term operator: '%s'\n", oper);

        pMoveToNextTkn();
        AstNode* rVarNode = pExpression();

        // debug
        if (!rVarNode) {
            printf("! SYNTAX ERROR: Expected valid expression after operator '%s'.\n", oper);
            free(oper); // Clean up
            return NULL; // Handle error
        }

        AstNode* exprNode = createNode(nodeExpression);
        exprNode -> data.Expression.lVar = termNode; 
        exprNode -> data.Expression.oper = oper;
        exprNode->data.Expression.rVar = rVarNode;
        termNode = exprNode;
    
    } 
    printf("Exiting pExpression()\n");
    return termNode;
}

#define MAX_ARGS 1000
AstNode* pFuncCall() {
    printf("Entering pFuncCall()\n");
    AstNode* funcCallNode = createNode(nodeFunctionCall);

    // Consume (EDIT: STORE) the function name
    funcCallNode -> data.funcCall.identifier = strdup(Tokens[pCurrentTknIndex - 1].value);

    pMoveToNextTkn(); // function identifier eaten

    printf("Token currently: '%s' (Type: %d)\n", pCurrentTkn().value, pCurrentTkn().type);
    
    // throwing errors so lets do some malloc bullcrap
    funcCallNode -> data.funcCall.args = malloc(sizeof(AstNode*) * MAX_ARGS);
    funcCallNode -> data.funcCall.argCount = 0;

    // Check for the left bracket
    if (pCurrentTkn().type == TknLBracket) {
        pMoveToNextTkn();  // Consume '('
    }
    else {
        printf("! SYNTAX ERROR: Expected '(' after functioncall.\n");
        exit(1);
    }
    // parse parameters
    if (pCurrentTkn().type != TknRBracket) {
        // Parse the first expression or parameter
        AstNode* paramNode = pExpression();
        // ok this is a hell of a line but basically what this is doing
        // is it accesses the funcCallNode that we've created 
        // and then puts in the paramNode at the index identified by argCount as far as i can tell lmao
        // cross fingers it works LMAO
        funcCallNode -> data.funcCall.args[funcCallNode -> data.funcCall.argCount++] = paramNode;

        // Check for additional parameters separated by commas
        while (pCurrentTkn().type == TknComma) {
            pMoveToNextTkn();  // Consume ','
            AstNode* paramNode = pExpression(); // Parse the next parameter
            funcCallNode -> data.funcCall.args[funcCallNode -> data.funcCall.argCount++] = paramNode;
        }
    }
        
    // Check for the right parenthesis ')'
    if (pCurrentTkn().type != TknRBracket) {
        printf("! SYNTAX ERROR: Expected ')' after function parameters.\n");
        exit(1);
    }
    pMoveToNextTkn();  // Consume ')'} 

    return funcCallNode;
}

#define MAX_VARIABLES 50

char variableNames[MAX_VARIABLES][12];
int variableCount = 0;

// Function to add a variable name
void addVariable(const char* name) {
    if (variableCount < MAX_VARIABLES) {
        strncpy(variableNames[variableCount++], name, 12);
    }
}

// parsing over statements
AstNode* pStmt() {
    printf("Entering pStmt() with node of type %d\n", pCurrentTkn().type);
    AstNode* stmtNode = createNode(nodeStmt);
    
    switch (pCurrentTkn().type) {
        case TknIdentifier:
            printf("Detected identifier: '%s'\n", pCurrentTkn().value); // debug
            
            if (doesFunctionExist(pCurrentTkn().value)) {
                printf("Function call detected for: '%s'\n", pCurrentTkn().value); // debug
                // function call
                stmtNode->data.stmt.data.funcCall.funcCall = pFuncCall();
                stmtNode->type = nodeFunctionCall;
            } else {
                printf("Assignment detected for: '%s'\n", pCurrentTkn().value); // debug
                // assignment
                addVariable(pCurrentTkn().value);
                stmtNode -> data.stmt.data.assignment.identifier = strdup(pCurrentTkn().value); // store identifier
                pMoveToNextTkn(); // move to next token
                printf("Current token after identifier: '%s' (Type: %d)\n", pCurrentTkn().value, pCurrentTkn().type);
                
                //check assignment operator correctly exists here
                if (pCurrentTkn().type == TknAssignmentOperator) {
                    printf("Assignment operator '<-' detected.\n");
                    pMoveToNextTkn(); // consume the assignment operator
                    
                    stmtNode -> data.stmt.data.assignment.exp = pExpression();
                    stmtNode -> type = nodeAssignment;
                
                    // validate expression exists for assignment operator 
                    if (!stmtNode->data.stmt.data.assignment.exp) {
                        printf("! SYNTAX ERROR: Expected a valid expression term after assignment operator '<-'.\n");
                        exit(EXIT_FAILURE);
                    }
                } else {
                    printf("! SYNTAX ERROR: Expected assignment operator '<-' after non-function name identifier.\n") ;
                    exit(EXIT_FAILURE);
                }     
                break;
            }

        case TknPrint:
            pMoveToNextTkn(); // eat print nom nom nom 
            stmtNode -> data.stmt.data.print.exp = pExpression();
            stmtNode -> type = nodePrint;

            // validate that expression exists
            if (!stmtNode->data.stmt.data.print.exp) {
                printf("! SYNTAX ERROR: Expected a valid expression after 'print'.\n");
                exit(EXIT_FAILURE);
            }
            break;

        case TknReturn:
            pMoveToNextTkn();
            stmtNode->data.stmt.data.returnStmt.exp = pExpression();
            stmtNode->type = nodeReturn;
            
            // Validate that the expression is valid
            if (!stmtNode->data.returnStmt.exp) {
                printf("! SYNTAX ERROR: Expected a valid expression after 'return'.\n");
                exit(EXIT_FAILURE);
            }
            break;
        default:
            // error rip
            printf("! SYNTAX ERROR: Unexpected token. valid statement starting args include print, return and function calls.");
            exit(EXIT_FAILURE);
    }

    printf("Exiting pStmt()\n");
    return stmtNode;
}

#define MAX_PARAMS 100
#define MAX_STATEMENTS 1000
// parsing over a function definition
AstNode* pFuncDef() {
    printf("Entering pFuncDef()\n"); // debugging
    // add node to tree
    AstNode* funcDefNode = createNode(nodeFunctionDef);
    pMoveToNextTkn();  // Go to next token

    // check if func exists
    if (pCurrentTkn().type == TknIdentifier) {
        if (doesFunctionExist(pCurrentTkn().value)) {  // check for if function already exists
            printf("! SYNTAX ERROR: Function name '%s' already definied\n", pCurrentTkn().value);
            exit(EXIT_FAILURE);
        }

        // otherwise add to func list
        addFunctionName(pCurrentTkn().value); // Store function name
        funcDefNode->data.funcDef.identifier = strdup(pCurrentTkn().value); // Function name
        funcDefNode->data.funcDef.params = (char**)malloc(sizeof(char*) * MAX_PARAMS); // CHECK THIS PLEASE
        funcDefNode->data.funcDef.paramCount = 0; // initalise to 0
        pMoveToNextTkn();
            
        while (pCurrentTkn().type == TknIdentifier) {
            if (funcDefNode -> data.funcDef.paramCount >= MAX_PARAMS) {
                printf("! SYNTAX ERROR: Too many params in func def, maximum allowed is %d.\n", MAX_PARAMS);
                exit(EXIT_FAILURE);
            }

            // add identifier to list of parameters
            funcDefNode->data.funcDef.params[funcDefNode->data.funcDef.paramCount++] = strdup(pCurrentTkn().value);
            pMoveToNextTkn();  
        }
        
        if (pCurrentTkn().type == TknNewline) {
            // valid function with no parameters do nothing
        } 
        else {
            printf("! SYNTAX ERROR: Expected newline or identifier after function name\n");
            exit(EXIT_FAILURE);
        }

        // Parse the function body (statements)
        funcDefNode->data.funcDef.stmt = (AstNode**)malloc(sizeof(AstNode*) * MAX_STATEMENTS); 
        funcDefNode->data.funcDef.stmtCount = 0;
        funcDefNode->data.funcDef.isReturn = 0; // init as 0

        while (pCurrentTkn().type == TknTab) { // Expecting indented statements
            if (funcDefNode->data.funcDef.stmtCount < MAX_STATEMENTS) {
                AstNode* stmtNode = pStmt();
                funcDefNode->data.funcDef.stmt[funcDefNode->data.funcDef.stmtCount++] = stmtNode; // Parse statement

                if (stmtNode->type == nodeReturn) {
                    funcDefNode -> data.funcDef.isReturn = 1;
                }
            
            } else {
                printf("@ Error: Too many statements in function body. Maximum is %d.\n", MAX_STATEMENTS);
                exit(EXIT_FAILURE);
            }

            if (pCurrentTkn().type == TknNewline) {
                pMoveToNextTkn(); // Move to next line
            } 
            else if (pCurrentTkn().type != TknTab) {
                break; // Exit loop if not indented anymore
            }
        }
    } 
    else {
        printf("! SYNTAX ERROR: Expected identifier for function name\n");
        exit(EXIT_FAILURE);
    }

    return funcDefNode; // Return the created function definition node
}

AstNode* pProgItem() {
    printf("Entering pProgItem()\n");
    // handle newlines (skip and continue)
    while (pCurrentTkn().type == TknNewline) {
        pMoveToNextTkn();
    }

    printf("Current Token: '%s' (Type: %d)\n", pCurrentTkn().value, pCurrentTkn().type);

    // check for if function definition exists
    if (pCurrentTkn().type == TknFunction) {
        return pFuncDef();
    } 
    else if (pCurrentTkn().type == TknIdentifier 
    || pCurrentTkn().type == TknPrint 
    || pCurrentTkn().type == TknReturn) {
        AstNode* stmtNode = pStmt();
        
        // debugging
        printf("Next Token after statement: '%s' (Type: %d)\n", pCurrentTkn().value, pCurrentTkn().type);

        // Expect newline or end after each statement
        if (pCurrentTkn().type == TknNewline) {
            return stmtNode;
        } else if (pCurrentTkn().type == TknEnd) {
            return stmtNode;  
        } else {
            printf("! SYNTAX ERROR: Expected newline or end after statement, got '%s'.\n", pCurrentTkn().value);
            exit(EXIT_FAILURE);
        }
        return stmtNode;
    } else if (pCurrentTkn().type == TknEnd) {
        // End of program, no further tokens expected
        return NULL;
    } else {
        // handle unexpected tokens
        printf("! SYNTAX ERROR: Unexpected token '%s'. Expected function definition or statement.\n", pCurrentTkn().value);
        exit(EXIT_FAILURE);
    }
}

#define MAX_LINES 10000
AstNode* pProgram() {
    printf("Entering pProgram()\n");
    AstNode* programNode = createNode(nodeProgram);
    
    // line count
    programNode -> data.program.lineCount = 0;
    programNode->data.program.programItems = (AstNode**)malloc(sizeof(AstNode*) * MAX_LINES); // CHECK THIS PLEASE
    if (!programNode -> data.program.programItems) {
        fprintf(stderr, "Memory alloc error.");
        exit(EXIT_FAILURE);
    }
    // parsing over program
    while (pCurrentTkn().type != TknEnd) {
        AstNode* programItem = pProgItem();
        if (programItem != NULL) {
            if (programNode -> data.program.lineCount < MAX_LINES) {
                programNode -> data.program.programItems[programNode->data.program.lineCount++] = programItem;
            } else {
                printf("! SYNTAX ERROR: Maximum line count exceeded.");
                exit(EXIT_FAILURE);
            }
        }
    }
    return programNode;
}

// ------------------------------------------- INTERPRETER-------------------------------------- //

//declare interpreter buffer size
#define BUFFER_SIZE 2048 // may change

char* codeBuffer; // Global buffer for C code
int bufferLength = 0;

// Free the buffer
void freeBuffer() {
    free(codeBuffer);
}

// Initialize buffer
void initBuffer() {
    codeBuffer = malloc(BUFFER_SIZE); // CHECK THIS PLEASE
    if (!codeBuffer) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    codeBuffer[0] = '\0'; // Start with an empty string
}

/// Append string to buffer
void addToCodeBuffer(const char* str) {
    int len = strlen(str);
    if (bufferLength + len >= BUFFER_SIZE) {
        // Resize buffer if necessary
        char* newBuffer = realloc(codeBuffer, bufferLength + len + 1);
        if (!newBuffer) {
            fprintf(stderr, "Memory reallocation failed\n");
            freeBuffer(); // Clean up existing buffer
            exit(1);
        }
        codeBuffer = newBuffer;
    }
    strcat(codeBuffer, str);
    bufferLength += len;
}

//helper function
bool hasOperatorInExpression(const char* expression) {
    // Check for presence of operators in the expression string
    return (strstr(expression, "+") || strstr(expression, "-") || 
            strstr(expression, "*") || strstr(expression, "/"));
}

const char* getExpStr(AstNode* expr) {
    static char buffer[100]; 
    buffer[0] = '\0'; 

    if (!expr) return buffer;

    switch (expr->type) {
        case nodeFactor:
            snprintf(buffer, sizeof(buffer), "%s", expr->data.factor.identifier); // Adjust as needed
            break;
        case nodeExpression:
            snprintf(buffer, sizeof(buffer), "%s %s %s",
                getExpStr(expr->data.Expression.lVar),
                expr->data.Expression.oper,
                getExpStr(expr->data.Expression.rVar));
            break;
        default:
            break;
    }
    return buffer;
}


void replaceAssiType(char* buffer) {
    //check assitype exists in buffer
    if (!strstr(buffer, "AssiType")) {
        return; // no replacements needed
    }
    
    size_t bufferLength = strlen(buffer); // length of original buffer    
    // create new buffer for modifed string
    char* newBuffer = malloc(bufferLength + 1); // Check this
    if (!newBuffer) {
        fprintf(stderr, "Memory allocation failed\n");
        return;
    }
    
    size_t newBufferIndex = 0;
    char varName[13]; // var name should only be 12 long -> so 12 + 1 for null character
    
    // Iterate through the original buffer line by line
    char* line = strtok(buffer, "\n");
    while (line) {
        char* linePos = line;
        while ((linePos = strstr(linePos, "AssiType"))) {
            // get variable name
            sscanf(linePos, "AssiType %12s", varName);

            // check if the variable is used with an operator
            bool isInt = hasOperatorInExpression(line); // simplified logic from previous if statement

            // copy the part of the line before "AssiType" to the new buffer
            size_t prefixLength = linePos - line;
            newBufferIndex += prefixLength;

            // strncpy(newBuffer + newBufferIndex, line, linePos - line);
            //newBufferIndex += linePos - line;

            const char* type = isInt ? "int " : "float ";

            // Replace "assitype" with "int" or "float"
            strcpy(newBuffer + newBufferIndex, type);
            
            /*
            if (isInt) {
                strcpy(newBuffer + newBufferIndex, "int ");
            } else {
                strcpy(newBuffer + newBufferIndex, "float ");
            }
            newBufferIndex += isInt ? 4 : 6; // length of inserted stuff

            // move past assitype in line
            linePos += strlen("AssiType");
            */
        
        // copy rest of line
        if (*linePos) {
            strcpy(newBuffer + newBufferIndex, linePos);
            newBufferIndex += strlen(linePos);
        }

        /*
        if (linePos && *linePos) {
            strcpy(newBuffer + newBufferIndex, linePos);
            newBufferIndex += strlen(linePos);
        }
        */
        break;
    
        }
        // add newline if not last line
        newBuffer[newBufferIndex++] = '\n';

        // get next line
        line = strtok(NULL, "\n");
    }

    // null terminate new generated buffer code
    newBuffer[newBufferIndex] = '\0';

    // copy new buffer back to og buffer
    strcpy(buffer, newBuffer);

    // Free (delete) new buffer
    free(newBuffer);
}

void writeCFile() {
    FILE *cFile = fopen("mlProgram.c", "w");
    if (cFile == NULL) {
        fprintf(stderr, "! Error: Could not create C file\n");
        return;
    }
    fprintf(cFile, "%s", codeBuffer); // buffer to file
    fclose(cFile);
}

// defining translation to rudimentaty C program
void toC(AstNode* node) {

    // first we gotta check if the node is existing
    if (!node) {
        return;
    }
    switch (node->type) {
        case nodeProgram:
            addToCodeBuffer("#include <stdio.h>\n\n");

             // Generate variable declarations
            for (int i = 0; i < variableCount; i++) {
                addToCodeBuffer("float ");
                addToCodeBuffer(variableNames[i]);
                addToCodeBuffer(";\n");
            }

            // Flag to check if funcdef exists
            bool functionDefined = false;
            // First pass to collect global variable assignments
            for (int i = 0; i < node->data.program.lineCount; i++) {
                if (node->data.program.programItems[i]->type == nodeAssignment && !functionDefined) { // CHECK THIS
                    // Handle global variable
                    addToCodeBuffer("AssiType "); // to do
                    addToCodeBuffer(node->data.program.programItems[i]->data.stmt.data.assignment.identifier);
                    addToCodeBuffer(" = ");
                    toC(node->data.program.programItems[i]->data.stmt.data.assignment.exp);
                    addToCodeBuffer(";\n");
                } else if (node->data.program.programItems[i]->type == nodeFunctionDef) {
                    functionDefined = true; // Mark that we've seen a function
                    toC(node->data.program.programItems[i]); // Process function definitions
                }
            }

            // add main functions
            addToCodeBuffer("int main() {\n");
            bool hasReturn = false; // flag to track if a return statement is made in main

            // Process all statements that should be executed in main
            for (int j = 0; j < node->data.program.lineCount; j++) {
                if (node->data.program.programItems[j]->type == nodePrint) { // check this
                    toC(node->data.program.programItems[j]);
                } else if (node->data.program.programItems[j]->type == nodeAssignment && functionDefined) { //check this
                    toC(node->data.program.programItems[j]);
                } else if (node->data.program.programItems[j]->type == nodeReturn) { // check this
                    toC(node->data.program.programItems[j]);
                    hasReturn = true;
                }
            }
            // Only add return 0 if no return statement has been encountered
            if (!hasReturn) {
                addToCodeBuffer("    return 0;\n");
            }
            addToCodeBuffer("}\n");
            break;
        
        case nodeFunctionDef:
            if (node->data.funcDef.isReturn == 1) {
                addToCodeBuffer("int ");
            }
            else if (node->data.funcDef.isReturn == 0) {
                addToCodeBuffer("void ");
            }
            else { 
                fprintf(stderr, "IDK what the fuck happened here\n");
                exit(1);
            }
            addToCodeBuffer(node->data.funcDef.identifier);
            addToCodeBuffer("(");

            for (int i = 0; i < node->data.funcDef.paramCount; i++) {
                if (i > 0) addToCodeBuffer(", "); // need to change
                    addToCodeBuffer("int ");
                    addToCodeBuffer(node->data.funcDef.params[i]);
            }
            addToCodeBuffer(") {\n");

            for (int j = 0; j < node->data.funcDef.stmtCount; j++) {
                toC(node->data.funcDef.stmt[j]);
            }
            addToCodeBuffer("}\n\n");
            break;

        case nodeAssignment:
            addToCodeBuffer("AssiType ");
            addToCodeBuffer(node->data.stmt.data.assignment.identifier);
            addToCodeBuffer(" = ");
            toC(node->data.assignment.exp);
            addToCodeBuffer(";\n");
            break;

        case nodePrint:
            addToCodeBuffer("printf(");
            
            // Create a buffer to hold the expression string
            char expStr[100]; 
            snprintf(expStr, sizeof(expStr), "%s", getExpStr(node->data.stmt.data.print.exp)); 

            // Determine the format string based on the expression
            char* formatStr = hasOperatorInExpression(expStr) ? "\"%d\\n\"" : "\"%f\\n\"";
            addToCodeBuffer(formatStr);
            
            addToCodeBuffer(", ");
            
            // Output the full expression to the buffer
            toC(node->data.stmt.data.print.exp);
            
            addToCodeBuffer(");\n");
            break;

        case nodeReturn:
            addToCodeBuffer("return ");
            toC(node->data.stmt.data.returnStmt.exp);
            addToCodeBuffer(";\n");
            break;

        case nodeExpression:
            toC(node->data.Expression.lVar);
            addToCodeBuffer(node->data.Expression.oper);
            toC(node->data.Expression.rVar);
            break;

        case nodeFunctionCall:
            addToCodeBuffer(node->data.funcCall.identifier);
            addToCodeBuffer("(");
            for (int i = 0; i < node->data.funcCall.argCount; i++) {
                if (i > 0) {
                    addToCodeBuffer(",");
                }
                toC(node->data.funcCall.args[i]);
            }
            addToCodeBuffer(");\n");
            break;

        case nodeFactor:
            if (node->data.factor.identifier) { // identifier exists
                addToCodeBuffer(node->data.factor.identifier);
            }
            else if (node->data.factor.funcCall) { // else if function call exists
                toC(node->data.factor.funcCall);
            }
            else if (node->data.factor.exp) { // if expression exists
                toC(node->data.factor.exp);
            }
            else { // otherwise treat as constant
                char buffer[50]; // Adjust size as needed
                snprintf(buffer, sizeof(buffer), "%.6f", node->data.factor.constant);
                addToCodeBuffer(buffer);
            }
            break;

        default:
            // Handle error or unsupported node types
            fprintf(stderr, "unknown AST node type: %d\n", node->type);
    }
}

// ------------------- TESTING ------------------- //

const char* testCode = "# 24 is printed\nx <- 8\ny <- 3\nprint x * y";

const char* additionalTests[] = {
    "function noParams\n    return 0\n#",
    "function singleParam x\n    return x + 1\n#",
    "function multipleParams x, y\n    return x + y\n#",
    "function invalidParam 1a\n    return 0\n#", // Invalid identifier
    "one <- 1\nprint one\n#", // Simple assignment and print
    "function nestedFunc\n    return increment(2)\n#\nprint nestedFunc()\n#", // Nested function calls
    "function withReturn x\n    return (x + 1)\n#",
    "function emptyFunc\n#",
    "function paramError x, y, \n#",
    "function repeatName x\n    return x\nfunction repeatName x\n    return x + 1\n#" // Duplicate function name
};

void testLexer() {
    printf("Testing Lexer:\n");
    
    // Tokenize the test code
    tokenize(testCode);

    // Print all tokens (assuming you have a way to access Tokens array)
    for (int i = 0; i < TknCount; i++) {
        print_token(Tokens[i]); // Make sure you have a print function for tokens
    }
}

void runTest(const char* testCode) {
    // Initialize the buffer for generated C code
    initBuffer();
    
    // Tokenize the test code
    tokenize(testCode);
    pCurrentTknIndex = 0;

    // Parse the code and build the AST
    AstNode* result = pProgram(); 
    if (result != NULL) {
        replaceAssiType(codeBuffer);

        // Convert the AST to C code
        toC(result);
        

        // Write the generated C code to a file
        FILE *cFile = fopen("mlProgram.c", "w");
        if (cFile != NULL) {
            fputs(codeBuffer, cFile);
            fclose(cFile);
        } else {
            printf("Error writing C file.\n");
            return;
        }

        // Print the generated C code (for debugging)
        printf("Generated C code:\n%s\n", codeBuffer);

        // Optionally, you can compile and execute the C code using a system call
        system("gcc mlProgram.c -o mlProgram && ./mlProgram");

        printf("Test passed!\n");
    } else {
        printf("Test failed!\n");
    }

    // Free the buffer memory
    freeBuffer();

    system("rm mlProgram.c");
}

int main() {
    printf("Running initial test:\n");
    runTest(testCode); // Initial test case

    printf("\nRunning additional tests:\n");
    for (int i = 0; i < sizeof(additionalTests) / sizeof(additionalTests[0]); i++) {
        printf("\nRunning test %d:\n", i + 1);
        runTest(additionalTests[i]);
    }

    return 0;
}